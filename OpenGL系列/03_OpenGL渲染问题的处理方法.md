# 3.OpenGL渲染问题的处理方法

## 学习内容

* 渲染过程中可能产⽣的问题
* 油画渲染
* 正⾯面&背⾯面剔除
* 深度测试
* 多边形模型
* 多边形偏移
* 裁剪

## 一、在渲染过程中可能产⽣的问题

在绘制3D场景的时候,我们需要决定哪些部分是对观察者 可⻅的,或者哪些部分是对观察者不可⻅的.对于不可⻅的 部分,应该及早丢弃.例如在⼀个不透明的墙壁后,就不应该 渲染.这种情况叫做“隐藏⾯消除”(Hidden surface elimination).

![](../images/opengl_03_1.png)

### 1.1 解决方案：油画法

油画算法：先绘制场景中的离观察者较远的物体,再绘制较近的物体.

例如下⾯的图例：先绘制红⾊部分,再绘制⻩⾊部分,最后再绘制灰色部分,即可解决隐藏⾯消除的 问题。

![](../images/opengl_03_1_1.png)

### 1.2 油画法弊端

使⽤油画算法,只要将场景按照物理距离观察者的距离远近排序,由远及近的绘制即可.那么会出现什么问题? 如果三个三角形是叠加的情况,油画算法将⽆法处理.

![](../images/opengl_03_1_2.png)

### 1.3 解决⽅案：正背⾯剔除(Face Culling)

**⼀个3D图形,你从任何⼀个⽅向去观察,最多可以看到几个面?**

答案：最多3⾯. 从⼀个⽴⽅体的任意位置和⽅向上看,你用过不可能看到多于3个面.

**那么思考? 我们为何要多余的去绘制那根本看不到的3个面?**

如果我们能以某种方式去丢弃这部分数据,OpenGL在渲染的性能即可提⾼超过50%.

**如何知道某个面在观察者的视􏰀中不会出现?**

任何平⾯都有2个面,正面/背面.意味着你⼀个时刻只能看到一⾯.OpenGL 可以做到检查所有正面朝向观察者的面,并渲染它们.从⽽丢弃背⾯朝向的⾯. 这样可以 节约⽚元着⾊器的性能.

**如果告诉OpenGL你绘制的图形,哪个面是正面,哪个面是背面?**

答案：通过分析顶点数据的顺序

### 1.4 分析顶点顺序

![](../images/opengl_03_1_4.png)

正⾯: 按照逆时针顶点连接顺序的三⻆形⾯

背⾯: 按照顺时针顶点连接顺序的三⻆形⾯

### 1.5 分析⽴方体中的正背⾯

![](../images/opengl_03_1_5.png)

#### 分析

* 左侧三⻆形顶点顺序为: 1—> 2—> 3; 右侧三⻆形的顶点顺序为: 1—> 2—> 3 . 
* 当观察者在右侧时,则右边的三⻆形⽅向为逆时针⽅方向判定为正⾯,⽽左侧的三⻆形为顺时针则为背面 
* 当观察者在左侧时,则左边的三角形⽅向为逆时针⽅方向判定为正⾯,⽽右侧的三⻆形为顺时针则为背面 

#### 总结

正⾯和背面是由三⻆形的顶点定义顺序和观察者方向共同决定的.随着观察者的⻆度⽅向的改变,正面背面也 会跟着改变。

### 1.6 开启正背面剔除

**开启表⾯剔除(默认背⾯剔除)**

```cpp
void glEnable(GL_CULL_FACE);
```

**关闭表面剔除(默认背⾯剔除)**

```cpp
void glDisable(GL_CULL_FACE);
```

**⽤户选择剔除那个面(正面/背面)**

```cpp
// mode参数为: GL_FRONT,GL_BACK,GL_FRONT_AND_BACK ,默认GL_BACK
void glCullFace(GLenum mode);
```

**⽤户指定绕序哪个为正⾯**

```cpp
// mode参数为: GL_CW,GL_CCW,默认值:GL_CCW
oid glFrontFace(GLenum mode); 
```

**例如,剔除正面实现(1)**

```cpp
glCullFace(GL_BACK);
glFrontFace(GL_CW);
```

**例如,剔除正面实现(1)**

```cpp
glCullFace(GL_FRONT);
```
