{"pages/面试系列/01_面试问题集锦.html":{"url":"pages/面试系列/01_面试问题集锦.html","title":"面试问题集锦1","keywords":"","body":"1.面试问题集锦 1. weak和assign的区别 一、什么情况使用 weak 关键字？ 在 ARC 中，在有可能出现循环引用的时候，往往要通过让其中一端使用 weak 来解决，比如： delegate 代理属性。 自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用 weak ，自定义 IBOutlet 控件属性一般也使用 weak ；当然，也可以使用 strong 。 二、区别 2.1. 修饰变量类型的区别 weak 只可以修饰对象。如果修饰基本数据类型，编译器会报错-“Property with ‘weak’ attribute must be of object type”。 assign 可修饰对象，和基本数据类型。当需要修饰对象类型时，MRC时代使用 unsafeunretained 。当然， unsafe_unretained 也可能产生野指针，所以它名字是 unsafe 。 2.2. 是否产生野指针的区别 weak 不会产生野指针问题。因为 weak 修饰的对象释放后（引用计数器值为0），指针会自动被置nil，之后再向该对象发消息也不会崩溃。 weak是安全的。 assign 如果修饰对象，会产生野指针问题；如果修饰基本数据类型则是安全的。修饰的对象释放后，指针不会自动被置空，此时向对象发消息会崩溃。 三、相同 都可以修饰对象类型，但是 assign 修饰对象会存在问题。 四、总结 assign 适用于基本数据类型如 int，float，struct 等值类型，不适用于引用类型。因为值类型会被放入栈中，遵循先进后出原则，由系统负责管理栈内存。而引用类型会被放入堆中，需要我们自己手动管理内存或通过 ARC 管理。weak 适用于 delegate 和 block 等引用类型，不会导致野指针问题，也不会循环引用，非常安全。 五、参考文章 iOS开发中 weak 和 assign 的区别 2. 为什么要用 Copy 修饰 Block 一、栈区和堆区概念 内存的栈区：由编译器自动分配释放，存放函数的参数值，局部变量的值等。 其操作方式类似于数据结构中的栈。 内存的堆区：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事， 分配方式倒是类似于链表。 二、Block 的三种类型 iOS 内存分布，一般分为：栈区、堆区、全局区、常量区、代码区。其实 Block 也是一个 Objective-C 对象，常见的有以下三种 Block ： NSGlobalBlock：全局的静态 Block 没有访问外部变量。 NSStackBlock：保存在栈中的 Block ，没有用copy去修饰并且访问了外部变量，会在函数调用结束被销毁（需要在MRC）。 NSMallocBlock：保存在堆中的 Block ， 此类型 Block 是用 Copy 修饰出来的 Block ，它会随着对象的销毁而销毁，只要对象不销毁，我们就可以调用的到在堆中的 Block 。 三、回答 Block 引用了普通外部变量，都是创建在栈区的；对于分配在栈区的对象，我们很容易会在释放之后继续调用，导致程序奔溃，所以我们使用的时候需要将栈区的对象移到堆区，来延长该对象的生命周期。对于这个问题，得区分 MRC 环境和 ARC 环境： 对于 MRC 环境，使用 Copy 修饰 Block，会将栈区的 Block 拷贝到堆区。 对于 ARC 环境，使用 Strong、Copy 修饰 Block，都会将栈区的 Block 拷贝到堆区。 所以，Block 不是一定要用 Copy 来修饰的，在 ARC 环境下面 Strong 和 Copy 修饰效果是一样的。 四、参考文章 iOS block 为什么用copy修饰 为什么要用copy修饰Block ·iOS 面试题·Block 的原理，Block 的属性修饰词为什么用 copy，使用 Block 时有哪些要注意的？ 3. 怎么用 Copy 关键字？ NSString、NSArray、NSDictionary 等等经常使用 Copy 关键字。因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。 Block 也经常使用 Copy 关键字。Block 使用 Copy 是从 MRC 遗留下来的“传统”，在 MRC 中，方法内部的 Block 是在栈区的，使用 Copy 可以把它放到堆区。 4. 这个写法会出什么问题：@property (copy) NSMutableArray *array; 添加，删除，修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象； 比如下面的代码就会发生崩溃 // .h文件 // http://weibo.com/luohanchenyilong/ // https://github.com/ChenYilong // 下面的代码就会发生崩溃 @property (nonatomic， copy) NSMutableArray *mutableArray; // .m文件 // http://weibo.com/luohanchenyilong/ // https://github.com/ChenYilong // 下面的代码就会发生崩溃 NSMutableArray *array = [NSMutableArray arrayWithObjects:@1，@2，nil]; self.mutableArray = array; [self.mutableArray removeObjectAtIndex:0]; 接下来就会奔溃： -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460 使用了 atomic 属性会严重影响性能； 该属性使用了互斥锁（atomic 的底层实现，老版本是自旋锁，iOS10开始是互斥锁--spinlock底层实现改变了。），会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。 5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。 具体步骤： 需声明该类遵从 NSCopying 协议 实现 NSCopying 协议。该协议只有一个方法: - (id)copyWithZone:(NSZone *)zone; 案例： .h文 // 件 // http://weibo.com/luohanchenyilong/ // https://github.com/ChenYilong // 以第一题《风格纠错题》里的代码为例 typedef NS_ENUM(NSInteger， CYLSex) { CYLSexMan， CYLSexWoman }; @interface CYLUser : NSObject @property (nonatomic， readonly， copy) NSString *name; @property (nonatomic， readonly， assign) NSUInteger age; @property (nonatomic， readonly， assign) CYLSex sex; - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex; + (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex; - (void)addFriend:(CYLUser *)user; - (void)removeFriend:(CYLUser *)user; @end // .m文件 // http://weibo.com/luohanchenyilong/ // https://github.com/ChenYilong // @implementation CYLUser { NSMutableSet *_friends; } - (void)setName:(NSString *)name { _name = [name copy]; } - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex { if(self = [super init]) { _name = [name copy]; _age = age; _sex = sex; _friends = [[NSMutableSet alloc] init]; } return self; } - (void)addFriend:(CYLUser *)user { [_friends addObject:user]; } - (void)removeFriend:(CYLUser *)user { [_friends removeObject:user]; } - (id)copyWithZone:(NSZone *)zone { CYLUser *copy = [[[self class] allocWithZone:zone] initWithName:_name age:_age sex:_sex]; copy->_friends = [_friends mutableCopy]; return copy; } - (id)deepCopy { CYLUser *copy = [[[self class] alloc] initWithName:_name age:_age sex:_sex]; copy->_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES]; return copy; } @end 至于如何重写带 copy 关键字的 setter这个问题， 如果抛开本例来回答的话，如下： - (void)setName:(NSString *)name { //[_name release]; _name = [name copy]; } 那如何确保 name 被 copy？在初始化方法(initializer)中做： - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex { if(self = [super init]) { _name = [name copy]; _age = age; _sex = sex; _friends = [[NSMutableSet alloc] init]; } return self; } 6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @property 的本质是什么？ @property = ivar + getter + setter; 下面解释下： “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。 “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示: 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说： @property = getter + setter; 例如下面这个类： @interface Person : NSObject @property NSString *firstName; @property NSString *lastName; @end 上述代码写出来的类与下面这种写法等效 @interface Person : NSObject - (NSString *)firstName; - (void)setFirstName:(NSString *)firstName; - (NSString *)lastName; - (void)setLastName:(NSString *)lastName; @end 源码分析 property在runtime中是 objc_property_t 定义如下: typedef struct objc_property *objc_property_t; 而 objc_property 是一个结构体，包括name和attributes，定义如下： struct property_t { const char *name; const char *attributes; }; 而attributes本质是 objc_property_attribute_t，定义了property的一些属性，定义如下： /// Defines a property attribute typedef struct { const char *name; /** 而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。 例如：我们定义一个string的property@property (nonatomic， copy) NSString *string;，通过 property_getAttributes(property)获取到attributes并打印出来之后的结果为T@\"NSString\"，C，N，V_string 其中T就代表类型，可参阅Type Encodings，C就代表Copy，N代表nonatomic，V就代表对应的实例变量。 ivar、getter、setter 是如何生成并添加到这个类中的? “自动合成”( autosynthesis) 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字. @implementation Person @synthesize firstName = _myFirstName; @synthesize lastName = _myLastName; @end 我为了搞清属性是怎么实现的，曾经反编译过相关的代码，他大致生成了五个东西 OBJCIVAR$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。 setter 与 getter 方法对应的实现函数 ivar_list ：成员变量列表 method_list ：方法列表 prop_list ：属性列表 也就是说我们每次在增加一个属性，系统都会在 ivar_list 中添加一个成员变量的描述，在 method_list 中增加 setter 与 getter 方法的描述，在属性列表中增加一个属性的描述，然后计算该属性在对象中的偏移量，然后给出 setter 与 getter 方法对应的实现，在 setter 方法中从偏移量的位置开始赋值，在 getter 方法中从偏移量开始取值，为了能够读取正确字节数，系统对象偏移量的指针类型进行了类型强转。 7. @protocol 和 category 中如何使用 @property 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性 category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数： objc_setAssociatedObject objc_getAssociatedObject 8. runtime 如何实现 weak 属性 要实现 weak 属性，首先要搞清楚 weak 属性的特点： weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 那么 runtime 如何实现 weak 变量的自动置nil？ runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。 9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？ 原子性--- nonatomic 特质 读/写权限---readwrite(读写)、readonly (只读) 内存管理语义---assign、strong、 weak、unsafe_unretained、copy 方法名---getter= 、setter= getter=的样式： @property (nonatomic, getter=isOn) BOOL on; setter=一般用在特殊的情境下，比如： 在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。 这时你就可以使用下面的方式来避免编译器报错： @property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy; 另外也可以用关键字进行特殊说明，来避免编译器报错： @property(nonatomic, readwrite, copy, null_resettable) NSString *initBy; - (NSString *)initBy __attribute__((objc_method_family(none))); 不常用的：nonnull,null_resettable,nullable 10. weak属性需要在dealloc中置nil么？ 不需要。 在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理 11. @synthesize和@dynamic分别有什么作用？ @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。 @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。 12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？ 对应基本数据类型默认关键字是 atomic readwrite assign 对于普通的 Objective-C 对象 atomic readwrite strong 13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？ 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性. copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动 成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？ 如果指定了成员变量的名称,会生成一个指定的名称的成员变量 如果这个成员已经存在了就不再生成了 如果是 @synthesize foo; 还会生成一个名称为foo的成员变量，也就是说 如果没有指定成员变量的名称会自动生成一个属性同名的成员变量 如果是 @synthesize foo = _foo; 就不会生成成员变量了。 14. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？ 回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？ 1. 同时重写了 setter 和 getter 时 2. 重写了只读属性的 getter 时 3. 使用了 @dynamic 时 4. 在 @protocol 中定义的所有属性 5. 在 category 中定义的所有属性 6. 重写（overridden）的属性 当你在子类中重写（overridden）了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。 当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择： 手动创建 ivar 使用@synthesize foo = _foo; ，关联 @property 与 ivar。 15. objc中向一个nil对象发送消息将会发生什么？ 在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用: 如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如： Person * motherInlaw = [[aPerson spouse] mother]; 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。 具体原因如下： objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。 objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。 16. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？ 该方法编译之后就是objc_msgSend()函数调用. ((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName(\"foo\")); 17. 什么时候会报unrecognized selector的异常？ 简单来说： 当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。 简单的流程如下，在上一题中也提到过： objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。 objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会： Method resolution objc运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。 Fast forwarding 如果目标对象实现了 -forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。 Normal forwarding 这一步是Runtime最后一次给你挽救的机会。首先它会发送 -methodSignatureForSelector: 消息获得函数的参数和返回值类型。如果 -methodSignatureForSelector: 返回nil，Runtime则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送 -forwardInvocation: 消息给目标对象。 18. 一个objc对象如何进行内存布局？（考虑有父类的情况） 所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中. 每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中） 成员变量的列表, 属性列表 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。 19. 一个objc对象的isa的指针指向什么？有什么作用？ isa 顾名思义 is a 表示对象所属的类。 isa 指向他的类对象，从而可以找到对象上的方法。 同一个类的不同对象，他们的 isa 指针是一样的 20. 下面的代码输出什么？ @implementation Son : Father - (id)init { self = [super init]; if (self) { NSLog(@\"%@\", NSStringFromClass([self class])); NSLog(@\"%@\", NSStringFromClass([super class])); } return self; } @end 都输出 Son 21. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法） 每一个类对象中都一个方法列表，方法列表中记录着方法的名称、方法实现、以及参数类型，其实selector 本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现。 参考 NSObject 上面的方法： - (IMP)methodForSelector:(SEL)aSelector; + (IMP)instanceMethodForSelector:(SEL)aSelector; 22. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？ 无论在MRC下还是ARC下均不需要。 23. objc中的类方法和实例方法有什么本质区别和联系？ 类方法： 类方法是属于类对象的 类方法只能通过类对象调用 类方法中的self是类对象 类方法可以调用其他的类方法 类方法中不能访问成员变量 类方法中不能直接调用对象方法 实例方法： 实例方法是属于实例对象的 实例方法只能通过实例对象调用 实例方法中的self是实例对象 实例方法中可以访问成员变量 实例方法中直接调用实例方法 实例方法中也可以调用类方法(通过类名) "},"pages/面试系列/02_面试问题集锦.html":{"url":"pages/面试系列/02_面试问题集锦.html","title":"面试问题集锦2","keywords":"","body":"1. _objc_msgForward函数是做什么的，直接调用它将会发生什么？ _objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。 2. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ 不能向编译后得到的类中增加实例变量； 能向运行时创建的类中添加实例变量； 解释下： 因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量； 运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。 3. runloop和线程有什么关系？ 总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。 主线程的run loop默认是启动的。 iOS的应用程序里面，程序启动后会有一个如下的main()函数 int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } } 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。 对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop NSRunLoop *runloop = [NSRunLoop currentRunLoop]; 4. runloop的mode作用是什么？ model 主要是用来指定事件在运行循环中的优先级的，分为： NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态 UITrackingRunLoopMode：ScrollView滑动时 UIInitializationRunLoopMode：启动时 NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合 苹果公开提供的 Mode 有两个： NSDefaultRunLoopMode（kCFRunLoopDefaultMode） NSRunLoopCommonModes（kCFRunLoopCommonModes） 5. 以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？ RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。 如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。 同时因为mode还是可定制的，所以： Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下： //将timer添加到NSDefaultRunLoopMode中 [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES]; //然后再添加到NSRunLoopCommonModes里 NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 6. 猜想runloop内部是如何实现的？ 一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑 是这样的： function loop() { initialize(); do { var message = get_next_message(); process_message(message); } while (message != quit); } 或使用伪代码来展示下: int main(int argc, char * argv[]) { //程序一直运行状态 while (AppIsRunning) { //睡眠状态，等待唤醒事件 id whoWakesMe = SleepForWakingUp(); //得到唤醒事件 id event = GetEvent(whoWakesMe); //开始处理事件 HandleEvent(event); } return 0; } 7. objc使用什么机制管理对象内存？ 通过 retainCount 的机制来决定对象是否需要释放。 每次 runloop 的时候，都会检查对象的 retainCount，如果 retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。 8. ARC通过什么方式帮助开发者管理内存？ ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。 在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。 8. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建） 手动干预释放时机--指定 autoreleasepool 就是所谓的：当前作用域大括号结束时释放。 系统自动去释放--不手动指定 autoreleasepool Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。 9. BAD_ACCESS在什么情况下出现？ 访问了悬垂指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。 死循环 10. 苹果是如何实现autoreleasepool的？ autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成. objc_autoreleasepoolPush objc_autoreleasepoolPop objc_autorelease 看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。 11. 使用block时什么情况会发生引用循环，如何解决？ 一个对象中强引用了 block，在 block 中又强引用了该对象，就会发生循环引用。 ARC 下的解决方法是： 将该对象使用 weak 修饰符修饰之后再在 block 中使用。 id weak weakSelf = self; 或者 weak typeof(&*self)weakSelf = self 该方法可以设置宏 __weak ：不会产生强引用，指向的对象销毁时，会自动让指针置为 ni1 使用 unsafe_unretained 关键字，用法与 __weak 一致。 unsafe_unretained 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变。 也可以使用 block 来解决循环引用问题，用法为： block id weakSelf = self;，但不推荐使用。因为必须要调用该 block 方案才能生效，因为需要及时的将 __block 变量置为 nii。 12. 在block内如何修改block外部变量？ 先描述下问题： 默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上 __block 来让其写操作生效，示例代码如下: __block int a = 0; void (^foo)(void) = ^{ a = 1; }; foo(); //这里，a的值被修改为1 \"将 auto 从栈 copy 到堆\" “将 auto 变量封装为结构体(对象)” 13. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ 14. GCD的队列（dispatch_queue_t）分哪两种类型 串行队列Serial Dispatch Queue 并发队列Concurrent Dispatch Queue 15. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图） 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。 16. dispatch_barrier_async的作用是什么？ 在并发队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。 dispatch_barrier_async 函数会等待追加到Concurrent Dispatch Queue并发队列中的操作全部执行完之后，然后再执行 dispatch_barrier_async 函数追加的处理，等 dispatch_barrier_async 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。 打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 dispatch_barrier_async 函数追加的内容就如同 “上完厕所就上高速”这个动作。 （注意：使用 dispatch_barrier_async ，该函数只能搭配自定义并发队列 dispatch_queue_t 使用。不能使用： dispatch_get_global_queue ，否则 dispatch_barrier_async 的作用会和 dispatch_async 的作用一模一样。 ） 17. 苹果为什么要废弃dispatch_get_current_queue？ dispatch_get_current_queue函数的行为常常与开发者所预期的不同。 由于派发队列是按层级来组织的，这意味着排在某条队列中的块会在其上级队列里执行。 队列间的层级关系会导致检查当前队列是否为执行同步派发所用的队列这种方法并不总是奏效。dispatch_get_current_queue函数通常会被用于解决由不可以重入的代码所引发的死锁，然后能用此函数解决的问题，通常也可以用\"队列特定数据\"来解决。 18. 以下代码运行结果如何？ - (void)viewDidLoad { [super viewDidLoad]; NSLog(@\"1\"); dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\"2\"); }); NSLog(@\"3\"); } 只输出：1 。发生主线程锁死。 19. 如何手动触发一个value的KVO 所谓的“手动触发”是区别于“自动触发”： 自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。 想知道如何手动触发，必须知道自动触发 KVO 的原理： 键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey: 。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， observeValueForKey:ofObject:change:context: 会被调用，继而 didChangeValueForKey: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。 那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。 20. 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？ 都可以 21. KVC的keyPath中的集合运算符如何使用？ 必须用在集合对象上或普通对象的集合属性上 简单集合运算符有@avg， @count ， @max ， @min ，@sum 格式 @\"@sum.age\"或 @\"集合属性.@max.age\" 22. KVC和KVO的keyPath一定是属性么？ KVC 支持实例变量，KVO 只能手动支持手动设定实例变量的KVO实现监听 23. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？ 《如何自己动手实现 KVO》 KVO for manually implemented properties 24. apple用什么方式实现对一个对象的KVO？ 当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例 25. IBOutlet连出来的视图属性为什么可以被设置成weak? Should IBOutlets be strong or weak under ARC? 文章告诉我们： 因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。 不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard 的私有数组强引用所有 top level 的对象，所以这时即便outlet声明成weak也没关系 26. IB中User Defined Runtime Attributes如何使用？ 它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller 27. 如何调试BAD_ACCESS错误 重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object 通过 Zombie 设置全局断点快速定位问题代码所在行 Xcode 7 已经集成了BAD_ACCESS捕获功能：Address Sanitizer。 28. lldb（gdb）常用的调试命令？ breakpoint 设置断点定位到某一个函数 n 断点指针下一步 po打印对象 "},"pages/面试系列/取东西.html":{"url":"pages/面试系列/取东西.html","title":"取东西","keywords":"","body":"取东西 测试一下 // 初始化每行数量 var row1Count = 3; var row2Count = 5; var row3Count = 7; // 获取行剩余数量 function getRemainCount(rowNum) { switch(parseInt(rowNum)) { case 1: return row1Count; case 2: return row2Count; case 3: return row3Count; default: return 0; } } // 更新行数量 // rowNum: 第几行（1,2,3） // getCount: 取数量 function updateRemainCount(rowNum, getCount) { switch(parseInt(rowNum)) { case 1: row1Count -= getCount; break; case 2: row2Count -= getCount; break; case 3: row3Count -= getCount; break; default: break; } }; // 判断是否取完所有 function judgeFinish() { return (row1Count + row2Count + row3Count) 0) { if (getCount > remainCount) { return -3;// 第x行数量不足 } else { // 更新行数量 updateRemainCount(rowNum, getCount); // 判断是否取完 if (judgeFinish()) { return -1;// 你是输家 } return 0;// 成功取出 } } else { return -2;// 第x行空 } } // 执行回合 // getCount: 取数量 // rowNum: 第几行（1,2,3） function round(rowNum, getCount) { var result = getThing(rowNum, getCount); switch(result) { case 0: alert(\"成功取出\"); break; case -1: alert(\"你是输家\"); break; case -2: alert(\"第\"+rowNum+\"行空\"); break; case -3: alert(\"第\"+rowNum+\"行数量不足\"); break; default: break; } }; // 运行 function run() { var rowNum = prompt(\"取第几行:\",\"\"); var getCount = prompt(\"取多少:\",\"\"); round(rowNum, getCount); } 15个任意物品（可以是火柴牙签poker） 以下按牙签为例 将15根牙签 分成三行 每行自上而下（其实方向不限）分别是3、5、7根 安排两个玩家，每人可以在一轮内，在任意行拿任意根牙签，但不能跨行 拿最后一根牙签的人即为输家 题目 请用你最擅长的语言，以你觉得最优雅的方式写一个符合以上游戏规则的程序。完成后把写好的代码和简历同时发到以下邮箱（备注姓名+岗位），并加上一段简短的文字描述一下你的想法 （请使用javascript，typescript或C#的其中一种语言完成测试题） "},"pages/面试系列/sizeof.html":{"url":"pages/面试系列/sizeof.html","title":"sizeof","keywords":"","body":"sizeof 面试官：定义一个空的类型，里面没有任何成员变量和成员函数。对 该类型求sizeof，得到的结果是多少？应聘者：答案是1。 面试官：为什么不是0？应聘者：空类型的实例中不包含任何信息，本来求sizeof应该是0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。在Visual Studio中，每个空类型的实例占用1字节的空间。 面试官：如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof,得到的结果又是多少？应聘者：和前面一样，还是1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数而在实例内添加任何额外的信息。 面试官：那如果把析构函数标记为虚函数呢？应聘者：C+的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占4字节的空间，因此求sizeof得到4；如果是64位的机器，则一个指针占8字节的空间，因此求sizeof得到8。 测试代码： #include using namespace std; class X { }; class Y: public virtual X { }; class Z: public virtual X { }; class A: public Y, public Z { }; int main() { int x = 0; x = sizeof(X); cout 在Xcode上的执行结果： x：1 y：8 z：8 a：16 参考链接：https://blog.csdn.net/zhuiqiuzhuoyue583/article/details/92846054 "},"pages/面试系列/复制构造函数.html":{"url":"pages/面试系列/复制构造函数.html","title":"复制构造函数","keywords":"","body":"复制构造函数 比如，面试官递给应聘者一张有如下代码的A4打印纸要求他分析编译运行的结果，并提供3个选项：A.编译错误；B.编译成功，运行时程序崩溃；C.编译运行正常，输出10。 在上述代码中，复制构造函数A(A other)传入的参数是A的一个实例。由于是传值参数，我们把形参复制到实参会调用复制构造函数。因此，如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永无休止的递归调用从而导致栈溢出。因此，C+的标准不允许复制构造函数传值参数，在Visual Studio和GCC中，都将编译出错。要解决这个问题，我们可以把构造函数修改为A(const A&other),也就是把传值参数改成常量引用。 "},"pages/面试系列/赋值运算符函数.html":{"url":"pages/面试系列/赋值运算符函数.html","title":"赋值运算符函数","keywords":"","body":"赋值运算符函数 题目：如下为类型CMyString的声明，请为该类型添加赋值运算符函数。 class CMyString { public: CMyString(char* pData = nullptr); CMyString(const CMyString& str); ~CMyString(void); CMyString& operator = (const CMyString& str); void Print(); private: char* m_pData; }; 当面试官要求应聘者定义一个赋值运算符函数时，他会在检查应聘者写出的代码时关注如下几点： 是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)。只有返回一个引用，才可以允许连续赋值。否则，如果函数的返回值是void,则应用该赋值运算符将不能进行连续赋值。假设有3个CMyString的对象：strl、str2和str3,在程序中语句str1=str2=str3将不能通过编译。 是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数。把参数声明为引用可以避免这样的无谓消耗，能提高代码的效率。同时，我们在赋值运算符函数内不会改变传入的实例的状态，因此应该为传入的引用参数加上const关键字。 是否释放实例自身已有的内存。如果我们忘记在分配新内存之前释放自身已有的空间，则程序将出现内存泄漏。 判断传入的参数和当前的实例(*this)是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果事先不判断就进行赋值，那么在释放实例自身内存的时候就会导致严重的问题：当*this和传入的参数是同一个实例时，一旦释放了自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。 经典的解法，适用于初级程序员 当我们完整地考虑了上述4个方面之后，可以写出如下的代码： CMyString& CMyString::operator = (const CMyString& str) { if(this == &str) return *this; delete []m_pData; m_pData = nullptr; m_pData = new char[strlen(str.m_pData) + 1]; strcpy(m_pData, str.m_pData); return *this; } 考虑异常安全性的解法，高级程序员必备 在前面的函数中，我们在分配内存之前先用delete释放了实例m_pData的内存。如果此时内存不足导致new char抛出异常，则m_pData将是一个空指针，这样非常容易导致程序崩溃。也就是说，一旦在赋值运算符函数内部抛出一个异常，CMyString的实例不再保持有效的状态，这就违背了异常安全性(Exception Safety)原则。 要想在赋值运算符函数中实现异常安全性，我们有两种方法。一种简单的办法是我们先用new分配新内容，再用delete释放已有的内容。这样只在分配内容成功之后再释放原来的内容，也就是当分配内存失败时我们能确保CMyString的实例不会被修改。我们还有一种更好的办法，即先创建一个临时实例，再交换临时实例和原来的实例。下面是这种思路的参考代码： CMyString& CMyString::operator = (const CMyString& str) { if(this != &str) { CMyString strTemp(str); char*pTemp=strTemp.m_pData; strTemp.m_pData=m_pData; m_pData=pTemp; } return *this; } 在这个函数中，我们先创建一个临时实例strTemp,接着把strTemp.m_pData和实例自身的m_pData进行交换。由于strTemp是一个局部变量，但程序运行到if的外面时也就出了该变量的作用域，就会自动调用strTemp的析构函数，把strTemp.m_pData所指向的内存释放掉。由于strTemp.m_pData指向的内存就是实例之前m_pData的内存，这就相当于自动调用析构函数释放实例的内存。 在新的代码中，我们在CMyString的构造函数里用new分配内存。如果由于内存不足抛出诸如bad alloc等异常，但我们还没有修改原来实例的状态，因此实例的状态还是有效的，这也就保证了异常安全性。 源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/01_AssignmentOperator "},"pages/面试系列/实现Singleton模式.html":{"url":"pages/面试系列/实现Singleton模式.html","title":"实现Singleton模式","keywords":"","body":"实现Singleton模式 题目：设计一个类，我们只能生成该类的一个实例： 不好的解法一：只适用于单线程环境 由于要求只能生成一个实例，因此我们必须把构造函数设为私有函数以禁止他人创建实例。我们可以定义一个静态的实例，在需要的时候创该实例。下面定义类型Singleton1就是基于这个思路的实现： public sealed class Singleton1 { private Singleton1() { } private static Singleton1 instance = null; public static Singleton1 Instance { get { if (instance == null) instance = new Singleton1(); return instance; } } } 上述代码在Singleton1的静态属性instance中，只有在instance为的时候才创建个实例以避免重复创建。同时我们把构造函数定义为私有函数，这样就能确保只创建一个实例。 不好的解法二：虽然在多线程环境中能工作，但效率不高 解法一中的代码在单线程的时候工作正常，但在多线程的情况下就有问题了。设想如果两个线程同时运行到判断instance是否为null的if语句，并且instance的确没有创建时，那么两个线程都会创建一个实例，此时类型Singleton1就不再满足单例模式的要求了。为了保证在多线程环境下我们还是只能得到类型的一个实例，需要加上一个同步锁。把Singleton1稍作修改得到了如下代码： public sealed class Singleton2 { private Singleton2() { } private static readonly object syncObj = new object(); private static Singleton2 instance = null; public static Singleton2 Instance { get { lock (syncObj) { if (instance == null) instance = new Singleton2(); } return instance; } } } 我们还是假设有两个线程同时想创建一个实例。由于在一个时刻只有一个线程能得到同步锁，当第一个线程加上锁时，第二个线程只能等待。当第一个线程发现实例还没有创建时，它创建出一个实例。接着第一个线程释放同步锁，此时第二个线程可以加上同步锁，并运行接下来的代码。这时候由于实例已经被第一个线程创建出来了，第二个线程就不会重复创建实例了，这样就保证了我们在多线程环境中也只能得到一个实例。 但是类型Singleton2还不是很完美。我们每次通过属性Instance得到Singleton2的实例，都会试图加上一个同步锁，而加锁是一个非常耗时的操作，在没有必要的时候我们应该尽量避免。 可行的解法：加同步锁前后两次判断实例是否已存在 我们只是在实例还没有创建之前需要加锁操作，以保证只有一个线程创建出实例。而当实例已经创建之后，我们已经不需要再执行加锁操作了。于是我们可以把解法二中的代码再做进一步的改进： public sealed class Singleton3 { private Singleton3() { } private static object syncObj = new object(); private static Singleton3 instance = null; public static Singleton3 Instance { get { if (instance == null) { lock (syncObj) { if (instance == null) instance = new Singleton3(); } } return instance; } } } Singleton3中只有当instance为null即没有创建时，需要加锁操作。当instance已经创建出来之后，则无须加锁。因为只在第一次的时候instance为null，因此只在第一次试图创建实例的时候需要加锁。这样Singleton3的时间效率比Singleton2要好很多。 Singleton3用加锁机制来确保在多线程环境下只创建一个实例，并且用两个if判断来提高效率。这样的代码实现起来比较复杂，容易出错，我们还有更加优秀的解法。 强烈推荐的解法一：利用静态构造函数 C#的语法中有一个函数能够确保只调用一次，那就是静态构造函数，我们可以利用C#的这个特性实现单例模式。 public sealed class Singleton4 { private Singleton4() { Console.WriteLine(\"An instance of Singleton4 is created.\"); } public static void Print() { Console.WriteLine(\"Singleton4 Print\"); } private static Singleton4 instance = new Singleton4(); public static Singleton4 Instance { get { return instance; } } } Singleton4的实现代码非常简洁。我们在初始化静态变量instance的时候创建一个实例。由于C#是在调用静态构造函数时初始化静态变量，.NET运行时能够确保只调用一次静态构造函数，这样我们就能够保证只初始化一次instance。 C#中调用静态构造函数的时机不是由程序员掌控的，而是当.NET运行时发现第一次使用一个类型的时候自动调用该类型的静态构造函数。因此在Singleton4中，实例instance并不是在第一次调用属性Singleton4.Instance的时候被创建的，而是在第一次用到Singleton4的时候就会被创建。假设我们在Singleton4中添加一个静态方法，调用该静态函数是不需要创建一个实例的，但如果按照Singleton4的方式实现单例模式，则仍然会过早地创建实 例，从而降低内存的使用效率。 强烈推荐的解法二：实现按需创建实例 最后一个实现Singleton5则很好地解决了Singleton4中的实例创建时机过早的问题。 public sealed class Singleton5 { Singleton5() { Console.WriteLine(\"An instance of Singleton5 is created.\"); } public static void Print() { Console.WriteLine(\"Singleton5 Print\"); } public static Singleton5 Instance { get { return Nested.instance; } } class Nested { static Nested() { } internal static readonly Singleton5 instance = new Singleton5(); } } 在上述Singleton5的代码中，我们在内部定义了一个私有类型Nested。当第一次用到这个嵌套类型的时候，会调用静态构造函数创建Singleton5的实例instance。类型Nested只在属性Singleton5.Instance中被用到，由于其私有属性，他人无法使用Nested类型。因此，当我们第一次试图通过属性Singleton5.Instance得到Singleton5的实例时，会自动调用Nested的静态构造函数创建实例instance。如果我们不调用属性Singleton5.Instance，就不会触发.NET运行时调用Nested，也不会创建实例，这样就真正做到了按需创建。 解法比较 在前面的5种实现单例模式的方法中，第一种方法在多线程环境能正常工作，第二种模式虽然能在多线程环境中正常工作，但时间效率很低，都不是面试官期待的解法。在第三种方法中，我们通过两次判断一次加锁确保在多线程环境中能高效率地工作。第四种方法利用C#的静态构造函数的特性，确保只创建一个实例。第五种方法利用私有嵌套类型的特性，做到只在真正需要的时候才会创建实例，提高空间使用效率。如果在面试中给出第四种或者第五种解法，则毫无疑问会得到面试官的青睐。 源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/02_Singleton "},"pages/面试系列/排序算法.html":{"url":"pages/面试系列/排序算法.html","title":"排序算法","keywords":"","body":"排序算法 冒泡排序 import Foundation func bubbleSort (arr: inout [Int]) { for i in 0.. arr[j+1] { arr.swapAt(j, j+1) } } } } // 测试调用 func testSort () { // 生成随机数数组进行排序操作 var list:[Int] = [] for _ in 0...99 { list.append(Int(arc4random_uniform(100))) } print(\"\\(list)\") bubbleSort(arr:&list) print(\"\\(list)\") } testSort() 选择排序 /// 选择排序 /// /// - Parameter list: 需要排序的数组 func selectionSort(_ list: inout [Int]) -> Void { for j in 0.. list[i] { minIndex = i } } list.swapAt(j, minIndex) } } 插入排序 func insertSort(list: inout [Int]) { for i in 1.. temp { list.swapAt(j, j+1) } } } } 希尔排序 public func insertSort(_ list: inout[Int], start: Int, gap: Int) { for i in stride(from: (start + gap), to: list.count, by: gap) { let currentValue = list[i] var pos = i while pos >= gap && list[pos - gap] > currentValue { list[pos] = list[pos - gap] pos -= gap } list[pos] = currentValue } } public func shellSort(_ list: inout [Int]) { var sublistCount = list.count / 2 while sublistCount > 0 { for pos in 0.. 快速排序 func quicksort(_ a: [T]) -> [T] { guard a.count > 1 else { return a } let pivot = a[a.count/2] let less = a.filter { $0 pivot } return quicksort(less) + equal + quicksort(greater) } 归并排序 func mergeSort(_ array: [Int]) -> [Int] { guard array.count > 1 else { return array } // 1 let middleIndex = array.count / 2 // 2 let leftArray = mergeSort(Array(array[0.. 堆排序 func heapSort(_ array : inout Array){ //1、构建大顶堆 //从二叉树的一边的最后一个结点开始 for i in (0...(array.count/2-1)).reversed() { //从第一个非叶子结点从下至上，从右至左调整结构 SortSummary.adjustHeap(&array, i, array.count) } //2、调整堆结构+交换堆顶元素与末尾元素 for j in (1...(array.count-1)).reversed() { //将堆顶元素与末尾元素进行交换 array.swapAt(0, j) //重新对堆进行调整 SortSummary.adjustHeap(&array, 0, j) } } //调整大顶堆（仅是调整过程，建立在大顶堆以构建的基础上） func adjustHeap(_ array : inout Array, _ i : Int, _ length : Int){ var i = i //取出当前元素i let tmp = array[i] var k = 2*i+1 //从i结点的左子节点开始，也就是2i+1处开始 while k tmp { array[i] = array[k] //记录当前结点 i = k }else{ break } //下一个结点 k = k*2+1 } //将tmp值放到最终的位置 array[i] = tmp } 参考 Swift算法俱乐部-希尔排序Swift算法俱乐部-归并排序swift算法之排序：（四）堆排序 十大经典排序算法常用算法面试题Swift算法俱乐部-快速排序Sort "},"pages/面试系列/RSA.html":{"url":"pages/面试系列/RSA.html","title":"RSA","keywords":"","body":"RSA 面试官：如何保证用户模块的数据安全？说说你的解决方案RSA算法介绍如何加密传输和存储用户密码 "},"pages/面试系列/面试题链接.html":{"url":"pages/面试系列/面试题链接.html","title":"面试题链接","keywords":"","body":"面试题链接 iOSInterviewsAndDevNotes iOS开发中 weak和assign的区别 做了快5年iOS，这份面试题让我从15K变成了30K 《招聘一个靠谱的iOS》面试题参考答案 iOS性能优化 iOS]NSHashTable和NSMapTable用法 Swift中的unowned和weak "},"pages/面试系列/数组与指针.html":{"url":"pages/面试系列/数组与指针.html","title":"数组与指针","keywords":"","body":"数组与指针 在C/C++中，数组和指针是既相互关联又有区别的两个概念。当我们声明一个数组时，其数组的名字也是一个指针，该指针指向数组的第一个元素。我们可以用一个指针来访问数组。但值得注意的是，C/C++没有记录数组的大小，因此在用指针访问数组中的元素时，程序员要确保没有超出数组的边界。下面通过一个例子来了解数组和指针的区别。运行下面的代码，请问输出是什么？ int GetSize(int data[]) { return sizeof(data); } int main(int argc, const char * argv[]) { int data1[] = {1,2,3,4,5}; int size1 = sizeof(data1); int* data2 = data1; int size2 = sizeof(data2); int size3 = GetSize(data1); printf(\"%d,%d,%d\",size1,size2,size3); return 0; } 答案是输出“20,4,4”。data1是一个数组，sizeof(data1)是求数组的大小。这个数组包含5个整数，每个整数占4字节，因此共占用20字节。data2声明为指针，尽管它指向了数组data1的第一个数字，但它的本质仍然是一个指针。在32位系统上，对任意指针求sizeof，得到的结果都是4。在C/C++中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针。因此，尽管函数GetSize的参数data被声明为数组，但它会退化为指针，size3的结果仍然是4。 剑指 Offer P38 "},"pages/面试系列/数组中重复的数字.html":{"url":"pages/面试系列/数组中重复的数字.html","title":"数组中重复的数字","keywords":"","body":"数组中重复的数字 题目一：找出数组中重复的数字。 在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。 解决这个问题的一个简单的方法是先把输入的数组排序。从排序的数组中找出重复的数字是一件很容易的事情，只需要从头到尾扫描排序后的数组就可以了。排序一个长度为n的数组需要O(nlogn)的时间。 还可以利用哈希表来解决这个问题。从头到尾按顺序扫描数组的每个数字，每扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入哈希表。如果哈希表里已经存在该数字，就找到一个重复的数字。这个算法的时间复杂度是O(n)，但它提高时间效率是以一个大小为O(n)的哈希表为代价的。我们再看看有没有空间复杂度是O(1)的算法。 我们注意到数组中的数字都在0~n-1的范围内。如果这个数组中没有重复的数字，那么当数组排序之后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。 现在让我们重排这个数组。从头到尾依次扫描这个数组中的每个数字。当扫描到下标为i的数字时，首先比较这个数字（用m表示）是不是等于i。如果是，则接着扫描下一个数字；如果不是，则再拿它和第m个数字进行比较。如果它和第m个数字相等，就找到了一个重复的数字（该数字在下标为i和m的位置都出现了)；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较、交换的过程，直到我们发现一个重复的数字。 以数组{2,3,1,0,2,5,3}为例来分析找到重复数字的步骤。数组的第0个数字（从0开始计数，和数组的下标保持一致）是2，与它的下标不相等，于是把它和下标为2的数字1交换。交换之后的数组是{1,3,2,0,2,5,3}。此时第0个数字是1，仍然与它的下标不相等，继续把它和下标为1的数字3交换，得到数组{3,1,2,0,2,5,3}。接下来继续交换第0个数字3和第3个数字0，得到数组{0,1,2,3,2,5,3}。此时第0个数字的数值为0，接着扫描下一个数字。在接下来的几个数字中，下标为1、2、3的3个数字分别为1、2、3，它们的下标和数值都分别相等，因此不需要执行任何操作。接下来扫描到下标为4的数字2。由于它的数值与它的下标不相等，再比较它和下标为2的数字。注意到此时数组中下标为2的数字也是2，也就是数字2在下标为2和下标为4的两个位置都出现了，因此找到一个重复的数字。 上述思路可以用如下代码实现： // 参数: // numbers: 一个整数数组 // length: 数组的长度 // duplication: (输出) 数组中的一个重复的数字 // 返回值: // true - 输入有效，并且数组中存在重复的数字 // false - 输入无效，或者数组中没有重复的数字 bool duplicate(int numbers[], int length, int* duplication) { if(numbers == nullptr || length length - 1) return false; } for(int i = 0; i 在上述代码中，找到的重复数字通过参数duplication传给函数的调用者，而函数的返回值表示数组中是否有重复的数字。当输入的数组中存在 重复的数字时，返回true；否则返回false。代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到属于它自己的位置，因此总的时间复杂度是O(n)。另外，所有的操作步骤都是在输入数组上进行的，不需要额外分配内存，因此空间复杂度为O(1)。 剑指 Offer P39，本题完整的源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/03_01_DuplicationInArray "},"pages/面试系列/数组中重复的数字2.html":{"url":"pages/面试系列/数组中重复的数字2.html","title":"数组中重复的数字2","keywords":"","body":"数组中重复的数字2 题用二，不修改数组找出重复的数字。 在一个长度为n+1的数组里的所有数字部在1~n的范面内，所以数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。 这一题看起来和上面的面试题类似。由于题目要求不能修改输入的数组，我们可以创建一个长度为n+1的辅助数组，然后逐一把原数组的每个数字复制到辅助数组。如果原数组中被复制的数字是m，则把它复制到辅助数组中下标为m的位置。这样很容易就能发现哪个数字是重复的。由于需要创建一个数组，该方案需要O(n)的辅助空间。 接下来我们尝试避免使用O(n)的辅助空间。为什么数组中会有重复的数字？假如没有重复的数字，那么在从1~n的范围里只有n个数字。由于数组里包含超过n个数字，所以一定包含了重复的数字。看起来在某范围里数字的个数对解决这个问题很重要。 我们把从1~n的数字从中间的数字m分为两部分，前面一半为1~m，后面一半为m+1~n。如果1~m的数字的数目超过m,那么这一半的区间里一定包含重复的数字；否则，另一半m+1~n的区间里一定包含重复的数字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。这个过程和二分查找算法很类似，只是多了一步统计区间里数字的数目。 我们以长度为8的数组{2,3,5,4,3,2,6,7}为例分析查找的过程。根据题目要求，这个长度为8的所有数字都在1~7的范围内。中间的数字4把1~7的范围分为两段，一段是1~4，另一段是5~7。接下来我们统计1～4这4个数字在数组中出现的次数，它们一共出现了5次，因此这4个数字中一定有重复的数字。 接下来我们再把1~4的范围一分为二，一段是1、2两个数字，另一段是3、4两个数字。数字1或者2在数组中一共出现了两次。我们再统计数字3或者4在数组中出现的次数，它们一共出现了三次。这意味着3、4两个数字中一定有一个重复了。我们再分别统计这两个数字在数组中出现的次数。接着我们发现数字3出现了两次，是一个重复的数字。 上述思路可以用如下代码实现： int countRange(const int* numbers, int length, int start, int end); // 参数: // numbers: 一个整数数组 // length: 数组的长度 // 返回值: // 正数 - 输入有效，并且数组中存在重复的数字，返回值为重复的数字 // 负数 - 输入无效，或者数组中没有重复的数字 int getDuplication(const int* numbers, int length) { if(numbers == nullptr || length = start) { // 0000 0010 >> 左移1位 0000 0101 int middle = ((end - start) >> 1) + start; int count = countRange(numbers, length, start, middle);// 查找落在二分左区间内个数 //cout 1) return start; else break; } if(count > (middle - start + 1))// 如果落在左区间的个数大于区间范围，则这里面一定有重复，否则就去右区间看看 end = middle; else start = middle + 1; } return -1; } int countRange(const int* numbers, int length, int start, int end) { if(numbers == nullptr) return 0; int count = 0; for(int i = 0; i = start && numbers[i] 上述代码按照二分查找的思路，如果输入长度为n的数组，那么函数countRange将被调用O(logn)次，每次需要O(n)的时间，因此总的时间复杂度是O(nlogn)，空间复杂度为O(1)。和最前面提到的需要O(n)的辅助空间的算法相比，这种算法相当于以时间换空间。 需要指出的是，这种算法不能保证找出所有重复的数字。例如，该算法不能找出数组{2,3,5,4,3,2,6,7}中重复的数字2。这是因为在1~2的范围里有1和2两个数字，这个范围的数字也出现2次，此时我们用该算法不能确定是每个数字各出现一次还是某个数字出现了两次。 从上述分析中我们可以看出，如果面试官提出不同的功能要求（找出任意一个重复的数字、找出所有重复的数字)或者性能要求（时间效率优先、空间效率优先)，那么我们最终选取的算法也将不同。这也说明在面试中和面试官交流的重要性，我们一定要在动手写代码之前弄清楚面试官的需求。 剑指 Offer P41，本题完整的源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/03_02_DuplicationInArrayNoEdit "},"pages/面试系列/二维数组中的查找.html":{"url":"pages/面试系列/二维数组中的查找.html","title":"二维数组中的查找","keywords":"","body":"二维数组中的查找 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的个二维数组和一个整数，判断数组中是否含有该整数。例如下面的二维数组就是每行、每列都递增排序。 如果在这个数组中查找数字7，则返回true;如果查找数字5，由于数组不含有该数字，则返回false。 1 2 8 9 2 4 9 1 4 7 9 12 6 8 11 15 在分析这个问题的时候，很多应聘者都会把二维数组画成矩形，然后从数组中选取一个数字，分3种情况来分析查找的过程。当数组中选取的数字刚好和要查找的数字相等时，就结束查找过程。如果选取的数字小于要查找的数字，那么根据数组排序的规则，要查找的数字应该在当前选取位置的右边或者下边，如图2.1(a)所示。同样，如果选取的数字大于要查找的数字，那么要查找的数字应该在当前选取位置的上边或者左边，如图2.1(b)所示。 图2.1二维数组中的查找 注：在数组中间选择一个数（深色方格），根据它的大小判断要查找的数字可能出现的区域（阴影部分）。 在上面的分析中，由于要查找的数字相对于当前选取的位置有可能在两个区域中出现，而且这两个区域还有重叠，这问题看起来就复杂了，于是很多人就卡在这里束手无策了。 当我们需要解决一个复杂的问题时，一个很有效的办法就是从一个具体的问题入手，通过分析简单具体的例子，试图寻找普遍的规律。针对这个问题，我们不妨也从一个具体的例子入手。下面我们以在题目中给出的数组中查找数字7为例来一步步分析查找的过程。 前面我们之所以遇到难题，是因为我们在二维数组的中间选取一个数字来和要查找的数字进行比较，这就导致下一次要查找的是两个相互重叠的区域。如果我们从数组的一个角上选取数字来和要查找的数字进行比较，那么情况会不会变简单呢？ 首先我们选取数组右上角的数字9。由于9大于7，并且9还是第4列的第一个（也是最小的）数字，因此7不可能出现在数字9所在的列。于是我们把这一列从需要考虑的区域内剔除，之后只需要分析剩下的3列，如图2.2(a)所示。在剩下的矩阵中，位于右上角的数字是8。同样8大于7，因此8所在的列我们也可以剔除。接下来我们只要分析剩下的两列即可，如图2.2(b)所示。 在由剩余的两列组成的数组中，数字2位于数组的右上角。2小于7，那么要查找的7可能在2的右边，也可能在2的下边。在前面的步骤中，我们已经发现2右边的列都已经被剔除了，也就是说7不可能出现在2的右边，因此7只有可能出现在2的下边。于是我们把数字2所在的行也剔除，只分析剩下的三行两列数字，如图2.2(c)所示。在剩下的数字中，数字4位于右上角，和前面一样，我们把数字4所在的行也删除，最后剩下两行两列数字，如图2.2（d)所示。 在剩下的两行两列4个数字中，位于右上角的刚好就是我们要查找的数字7，于是查找过程就可以结束了。 注：矩阵中加阴影的区域是下一步查找的范围。 总结上述杏找的讨程，我们发现如下规律：首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。 把整个查找过程分析清楚之后，我们再写代码就不是一件很难的事情了。下面是上述思路对应的参考代码： bool Find(int* matrix, int rows, int columns, int number) { bool found = false; if(matrix != nullptr && rows > 0 && columns > 0) { int row = 0; int column = columns - 1; while(row =0) { if(matrix[row * columns + column] == number) { found = true; break; } else if(matrix[row * columns + column] > number) -- column; else ++ row; } } return found; } 在前面的分析中，我们每次都选取数组查找范围内的右上角数字。同样，我们也可以选取左下角的数字。感兴趣的读者不妨自己分析一下每次都选取左下角数字的查找过程。但我们不能选择左上角数字或者右下角数字。以左上角数字为例，最初数字1位于初始数组的左上角，由于1小于7，那么7应该位于1的右边或者下边。此时我们既不能从查找范围内剔除1所在的行，也不能剔除1所在的列，这样我们就无法缩小查找的范围。 剑指 Offer P44，本题完整的源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/04_FindInPartiallySortedMatrix "},"pages/面试系列/替换空格.html":{"url":"pages/面试系列/替换空格.html","title":"替换空格","keywords":"","body":"替换空格 题目：请实现一个函数，把字符串中的每个空格替换成\"%20\"。例如，输入“We are happy.”，则输出“We%20are%20happy.”。 在网络编程中，如果URL参数中含有特殊字符，如空格、'#'等，则可能导致服务器端无法获得正确的参数值。我们需要将这些特殊符号转换成服务器可以识别的字符。转换的规则是在'%'后面跟上ASCII码的两位十六进制的表示。比如空格的ASCI码是32，即十六进制的0x20,因此空格被替换成\"%20\"。再比如'#'的ASCⅡ码为35，即十六进制的0x23，它在URL中被替换为\"%23\"。 看到这个题目，我们首先应该想到的是原来一个空格字符，替换之后变成'%'、'2'和'0'这3个字符，因此字符串会变长。如果是在原来的字符串上进行替换，就有可能覆盖修改在该字符串后面的内存。如果是创建新的字符串并在新的字符串上进行替换，那么我们可以自己分配足够多的内存。由于有两种不同的解决方案，我们应该向面试官问清楚，让他明确告诉我们他的需求。假设面试官让我们在原来的字符串上进行替换，并且保证输入的字符串后面有足够多的空余内存。 时间复杂度为O(n²)的解法，不足以拿到Offer 现在我们考虑怎么执行替换操作。最直观的做法是从头到尾扫描字符串，每次碰到空格字符的时候进行替换。由于是把1个字符替换成3个字符，我们必须要把空格后面所有的字符都后移2字节，否则就有两个字符被覆盖了。 举个例子，我们从头到尾把\"We are happy.\"中的每个空格替换成\"%20\"。为了形象起见，我们可以用一个表格来表示字符串，表格中的每个格子表示一个字符，如图2.3(a)所示。 注：(a)字符串\"We are happy.\"。(b)把字符串中的第一个空格替换成%20。灰色背景表示需要移动的字符。(c)把字符串中的第二个空格替换成%20。浅灰色背景表示需要移动一次的字符，深灰色背景表示需要移动两次的字符。 我们替换第一个空格，这个字符串变成图2.3（b）中的内容，表格中灰色背景的格子表示需要进行移动的区域。接着我们替换第二个空格，替换之后的内容如图2.3（c）所示。同时，我们注意到用深灰色背景标注的“happy”部分被移动了两次。 假设字符串的长度是n。对每个空格字符，需要移动后面O(n)个字符，因此对于含有O(n)个空格字符的字符串而言，总的时间效率是O(n²)。 当我们把这种思路阐述给面试官后，他不会就此满意，他将让我们寻找更快的方法。在前面的分析中，我们发现数组中很多字符都移动了很多次，能不能减少移动次数呢？答案是肯定的。我们换一种思路，把从前向后替换改成从后向前替换。 时间复杂度为O(n)的解法，搞定Offer就靠它了 我们可以先遍历一次字符串，这样就能统计出字符串中空格的总并可以由此计算出替换之后的字符串的总长度。每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。我们还是以前面的字符串\"We are happy.\"为例。\"We are happy.\"这个字符串的长度是14（包括结尾符号0），里面有两个空格，因此替换之后字符串的长度是18。 我们从字符串的后面开始复制和替换。首先准备两个指针：P1和P2。P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾，如图2.4(a)所示。接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。此时字符串如图2.4(b)所示，灰色背景的区域是进行了字符复制（移动）的区域。碰到第一个空格之后，把P1向前移动1格，在P2之前插入字符串\"%20\"。由于\"%20\"的长度为3，同时也要把P2向前移动3格，如图2.4(c)所示。 我们接着向前复制，直到碰到第二个空格，如图2.4(d)所示。和上一次一样，我们再把P1向前移动1格，并把P2向前移动3格插入\"%20”，如图2.4（e）所示。此时P1和P2指向同一位置，表明所有空格都已经替换完毕。 从上面的分析中我们可以看出，所有的字符都只复制（移动）一次，因此这个算法的时间效率是O(n)，比第一个思路要快。 注：图中带有阴影的区域表示被移动的字符。(a)把第一个指针指向字符串的末尾，把第二个指针指向替换之后的字符串的末尾。(b)依次复制字符串的内容，直至第一个指针碰到第一个空格。(c)把第一个空格替换成\"%20”，把第一个指针向前移动1格，把第二个指针向前移动3格。(d)依次向前复制字符串中的字符，直至碰到空格。（e）替换字符串中的倒数第二个空格，把第一个指针向前移动1格，把第二个指针向前移动3格。 在面试过程中，我们也可以和前面的分析一样画一两个示意图解释自己的思路，这样既能帮助我们厘清思路，也能使我们和面试官的交流变得更加高效。在面试官肯定我们的思路之后，就可以开始写代码了。下面是参考代码： /*length 为字符数组str的总容量，大于或等于字符串str的实际长度*/ void ReplaceBlank(char str[], int length) { if(str == nullptr && length length) return; int indexOfOriginal = originalLength; int indexOfNew = newLength; while(indexOfOriginal >= 0 && indexOfNew > indexOfOriginal) { if(str[indexOfOriginal] == ' ') { str[indexOfNew --] = '0'; str[indexOfNew --] = '2'; str[indexOfNew --] = '%'; } else { str[indexOfNew --] = str[indexOfOriginal]; } -- indexOfOriginal; } } 剑指 Offer P51，本题完整的源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/05_ReplaceSpaces "},"pages/面试系列/链表.html":{"url":"pages/面试系列/链表.html","title":"链表","keywords":"","body":"链表 链表应该是面试时被提及最频繁的数据结构。链表的结构很简单，它由指针把若干个节点连接成链状结构。链表的创建、插入节点、删除节点等操作都只需要20行左右的代码就能实现，其代码量比较适合面试。而像哈希表、有向图等复杂数据结构，实现它们的一个操作需要的代码量都较大，很难在几十分钟的面试中完成。另外，由于链表是一种动态的数据结构，其需要对指针进行操作，因此应聘者需要有较好的编程功底才能写出完整的操作链表的代码。而且链表这种数据结构很灵活，面试官可以用链表来设计具有挑战性的面试题。基于上述几个原因，很多面试官都特别青睐与链表相关的题目。 我们说链表是一种动态数据结构，是因为在创建链表时，无须知道链表的长度。当插入一个节点时，我们只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表当中。内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。由于没有闲置的内存，链表的空间效率比数组高。如果单向链表的节点定义如下： struct ListNode { int m_nValue; ListNode* m_pNext; }; 那么往该链表的末尾添加一个节点的C++代码如下： void AddToTail(ListNode**pHead, int value) { ListNode* pNew = new ListNode(); pNew->m_nValue = value; pNew->m_pNext = nullptr; if(*pHead == nullptr) { *pHead = pNew; } else { ListNode* pNode = *pHead; while(pNode->m_pNext != nullptr) pNode = pNode->m_pNext; pNode->m_pNext = pNew; } } 在上面的代码中，我们要特别注意函数的第一个参数pHead是一个指向指针的指针。当我们往一个空链表中插入一个节点时，新插入的节点就是链表的头指针。由于此时会改动头指针，因此必须把pHead参数设为指向指针的指针，否则出了这个函数pHead仍然是一个空指针。 由于链表中的内存不是一次性分配的，因而我们无法保证链表的内存和数组一样是连续的。因此，如果想在链表中找到它的第i个节点，那么我们只能从头节点开始，沿着指向下一个节点的指针遍历链表，它的时间效率为O(n)。而在数组中，我们可以根据下标在O(1)时间内找到第i个元素。下面是在链表中找到第一个含有某值的节点并删除该节点的代码： void RemoveNode(ListNode** pHead, int value) { if(pHead == nullptr || *pHead == nullptr) return; ListNode* pToBeDeleted == nullptr; if((*pHead)->m_nValue == value) { pToBeDeleted = *pHead; *pHead = (*pHead)->m_pNext; } else { ListNode* pNode = *pHead; while(pNode->m_pNext != nullptr && pNode->m_pNext->m_nValue != value) pNode = pNode->m_pNext; if(pNode->m_pNext != nullptr && pNode->m_pNext->m_nValue == value) { pToBeDeleted = pNode->m_pNext; pNode->m_pNext = pNode->m_pNext->m_pNext; } } if(pToBeDeleted != nullptr) { delete pToBeDeleted; pToBeDeleted = nullptr; } } 剑指 Offer P56 "},"pages/面试系列/从尾到头打印链表.html":{"url":"pages/面试系列/从尾到头打印链表.html","title":"从尾到头打印链表","keywords":"","body":"从尾到头打印链表 题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值链表节点定义如下： struct ListNode { int m_nKey; ListNode* m_pNext; }; 看到这道题后，很多人的第一反应是从头到尾输出将会比较简单，于是我们很自然地想到把链表中链接节点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。但该方法会改变原来链表的结构。是否允许在打印链表的时候修改链表的结构？这取决于面试官的要求，因此在面试的时候我们要询问清楚面试官的要求。 面试小提示：在面试中，如果我们打算修改输入的数据，则最好先问面试官是不是允许修改。 通常打印是一个只读操作，我们不希望打印时修改内容。假设面试官也要求这个题目不能改变链表的结构。 接下来我们想到解决这个问题肯定要遍历链表。遍历的顺序是从头到尾，可输出的顺序却是从尾到头。也就是说，第一个遍历到的节点最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这种顺序。每经过一个节点的时候，把该节点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出节点的值，此时输出的节点的顺序己经反转过来了。这种思路的实现代码如下： #include \"..\\Utilities\\List.h\" #include void PrintListReversingly_Iteratively(ListNode* pHead) { std::stack nodes; ListNode* pNode = pHead; while(pNode != nullptr) { nodes.push(pNode); pNode = pNode->m_pNext; } while(!nodes.empty()) { pNode = nodes.top(); printf(\"%d\\t\", pNode->m_nValue); nodes.pop(); } } 既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构，于是很自然地又想到了用递归来实现。要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。 基于这样的思路，不难写出如下代码： void PrintListReversingly_Recursively(ListNode* pHead) { if(pHead != nullptr) { if (pHead->m_pNext != nullptr) { PrintListReversingly_Recursively(pHead->m_pNext); } printf(\"%d\\t\", pHead->m_nValue); } } 上面的基于递归的代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一些。更多关于循环和递归的讨论，详见本书的2.4.1节。 剑指 Offer P58，本题完整的源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/06_PrintListInReversedOrder "},"pages/面试系列/面试准备.html":{"url":"pages/面试系列/面试准备.html","title":"面试准备","keywords":"","body":"面试准备 自我介绍 我的专业是计算机通信，9年iOS开发经验，3年Java开发经验，担任过iOS团队负责人，有团队管理经验，有组件化开发经验，具备独立开发能力，具备文档编写能力，有良好的代码习惯。 My major is computer communication. I have 9 years of experience in iOS development, 3 years of experience in Java development, and served as the head of the iOS team. I have experience in team management, component development, independent development, document writing, and good code habits. 如何学习 在工作中，如果遇到自己不会的问题，通过Google、百度相关资料，然后总结记录。学习一门新技术，我会通过查看其官方教程或找学习视频，同时买一本书籍阅读，然后实践，再根据自己的理解总结写文章记录。 职业规划 结合自身还有目前的职业环境，我有认真想过这个问题。在工作方面，我想通过积极完成工作任务，积累各方面经验，让自己成为这个领域的专业人士，也希望有机会能够带领团队，成为优秀的管理者，为单位作出更大的贡献，实现双赢。在学习方面，打算在iOS专业领域做进一步学习和研究，同时也学习Android、H5等技术，为以后自己成为管理者做下铺垫。 擅长技术 熟练OC、Swift、Java、RxSwift、MVVM、MVC、Cocoapods、GCD、Git Flow。熟悉C、C++、Maven、HTML、JS、CSS、SQL、Mysql、Tomcat、JDBC、SSH。了解Android、Flutter、ReactNative、libRTMP、OpenGLES、FFmpeg。 视频播放器 组件化开发 设计模式 排序算法 数据结构 RSA CICD SwiftUI 敏捷开发 提问环节 项目中会使用SwiftUI吗？ 项目是针对海外客户吗？ 一个功能需求下来，在开发人员开发着前，您最希望它做好哪些开发准备？ 项目中难免存在一些不得不进行重构优化的代码，您是如何看待这个问题的？ 面试问题 敏捷开发：敏捷开发的核心是迭代开发（iterative development）。敏捷一定是采用迭代开发的方式。 函数式编程：函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 线程间通信：内存共享、通知、等待、锁。 swift特性：元组、可选、解包、扩展、泛型、枚举、泛型关联、命名空间、权限关键字、协议、闭包。 内存管理：Swift使用自动引用计数（ARC）来简化内存管理，与OC一致。 swift语言、架构能力、block原理、swift特性、项目管理、代码规范。 参考链接 Swift 语言的一些功能特性为何面试时都会问你的职业规划呢？该如何回答呢？ "},"pages/面试系列/视频播放器.html":{"url":"pages/面试系列/视频播放器.html","title":"视频播放器","keywords":"","body":"视频播放器 实现一个播放器SDK，要求播放控制界面可定制，提供播放、暂停、停止、Seek等功能。 I帧、P帧、B帧 I帧表示关键帧，帧画面的完整保留，解码时只需要本帧数据就可以完成。 P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。 B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面，B帧压缩率高，但是解码时CPU会比较累。 视频如何播放？ 视频画面其实是由视频帧组成，分别为I帧、P帧、B帧。也就是说，显示视频画面需要对视频压缩格式进行遍历解码帧数据，遍历的同时对每一帧数据按照播放时间进行显示，每一帧可以理解为一张图片，其实就是对图片数据的显示。 视频如何显示？ 不仅是视频，显示问题无处不在，我们所有在手机端看到的画面都和视频一样，是一个不断刷新绘制的过程，底层都是通过使用OpenGL的API，对GPU硬件发出指令，通过图形渲染管线程序，最终在屏幕的每个像素点显示。OpenGL是跨平台的，iOS上是通过GLKView进行渲染显示。 什么是图形渲染管线？ 顶点着色器 —— 图元装配 —— 几何着色器 —— 光栅化 —— 片段着色器 —— 测试与混合。 着色器是一段运行在GPU中的程序；顶点着色器确定绘制图形的形状；图元装配是将顶点着色器传来的顶点数据组装为图元；光栅化是将一个图元转化为一张二维的图片，而这张图片由若干个片段（fragment）组成；片段着色器计算片段的颜色；测试和混合丢弃一些不需要显示的片段。 如何播放全景视频？ 在图形渲染管线中，顶点着色器和片元着色器是可编程的，也就是说我们可以通过顶点着色器构建任意事物模型顶点，然后通过过GPU进行绘制，再通过片元着色器给事物上色（纹理贴图）。普通的视频播放可以理解为就是在一个二维的面显示视频画面，二维的面就是顶点着色器构建的，而画面的显示则交给了片元着色器，那么全景视频的显示，其实就是在顶点着色器环节构建一个球面即可实现播放全景视频。 iOS上如何对MP4文件播放？ AVFoundation中的AVPlayer提供对视频压缩文件的播放。以下是播放步骤： 1）构建AVPlayerItem实例。2）通过KVO监听AVPlayerItem实例加载的状态，加载成功，否则播放失败，最后移除监听。3）构建播放器AVPlayer实例。4）为AVPlayerItem实例增加AVPlayerItemVideoOutput实例，加入异步队列。5）构建屏幕定时器，通过AVPlayerItemVideoOutput实例获取当前视频帧数据，交给OpengGL渲染。6）监听播放进度，播放结束。7）开始播放。 如何使用FFmpeg对MP4文件播放？ FFmpeg提供ffplay命令可以对几乎所有的视频压缩格式进行播放，包括yuv格式。 播放器设计 播发器类：CPVideoPlayer，提供播放、暂停、停止、Seek等方法。协议一：CPVideoPlayerDelegate，回调播放状态及视频数据。协议二：CPVideoPlayerDataSource，获取视频地址。协议三：CPVideoControlViewProtocol，播放控制界面。 播放器weak引用上面三个协议。 参考链接 一看就懂的OpenGL ES教程——图形渲染管线的那些事YUV图解I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系 "},"pages/面试系列/组件化开发.html":{"url":"pages/面试系列/组件化开发.html","title":"组件化开发","keywords":"","body":"组件化开发 如何优雅的使用CTMeditor？ 我们项目会有多个组件，比如：个人中心（Me），登录（Login）等，现在我想实现如下的写法： Mediator.shared.me Mediator.shared.login 以me为例子，建立Me的结构体，为Me增加扩展，如果Base为Mediator类型，那么可以拥有debugEnvironment方法。 public struct Me { public let base: Base public init(_ base: Base) { self.base = base } } extension Me where Base: Mediator { public func debugEnvironment(_ env: String) -> Bool { var deliverParams: [String: Any] = [\"env\": env] let result = base.performTarget(\"Me\", action: \"DebugEnvironment\", params: deliverParams) as? [String: Any] return (result?[\"result\"] as? Bool) ?? false } } 扩展Mediator，为Mediator增加me的实例 public protocol MeProtocol {} extension Mediator: MeProtocol {} extension MeProtocol { public var me: Me { return Me(self) } public static var me: Me.Type { return Me.self } } 通过以上操作就可以实现Mediator.shared.me.debugEnvironment(\"dev\")的调用。 CTMeditor实现原理？ 以Mediator.shared.me.debugEnvironment(\"dev\")为例分析，通过这段代码Mediator可以找到Target是类名为Target_Me的实例，方法名是debugEnvironment，参数\"dev\"封装成了字典，通过Runtime的perform方法就可以调用到目标逻辑。 蘑菇街组件化方案问题？ 1）蘑菇街没有拆分远程调用和本地间调用。2）蘑菇街以远程调用的方式为本地间调用提供服务。3）蘑菇街的本地间调用无法传递非常规参数，复杂参数的传递方式非常丑陋。4）蘑菇街必须要在app启动时注册URL响应者。5）新增组件化的调用路径时，蘑菇街的操作相对复杂。6）蘑菇街没有针对target层做封装。 组建化方案如何加载xib及其他资源文件？ 通过Class找到Bundle，然后构建Nib的时候传入制定的bundle。 参考链接 iOS应用架构谈 组件化方案 "},"pages/面试系列/设计模式.html":{"url":"pages/面试系列/设计模式.html","title":"设计模式","keywords":"","body":"设计模式 1) 状态模式 在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。 public class StatePatternDemo { public static void main(String[] args) { Context context = new Context(); StartState startState = new StartState(); startState.doAction(context); System.out.println(context.getState().toString()); StopState stopState = new StopState(); stopState.doAction(context); System.out.println(context.getState().toString()); } } 参考链接 菜鸟·设计模式 "},"pages/面试系列/数据结构.html":{"url":"pages/面试系列/数据结构.html","title":"数据结构","keywords":"","body":"数据结构 "},"pages/面试系列/CICD.html":{"url":"pages/面试系列/CICD.html","title":"CICD","keywords":"","body":"CICD "},"pages/面试系列/SwiftUI.html":{"url":"pages/面试系列/SwiftUI.html","title":"SwiftUI","keywords":"","body":"SwiftUI "},"pages/面试系列/敏捷开发.html":{"url":"pages/面试系列/敏捷开发.html","title":"敏捷开发","keywords":"","body":"敏捷开发 参考链接 敏捷开发入门教程 "},"./":{"url":"./","title":"最近更新","keywords":"","body":"从尾到头打印链表 题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值链表节点定义如下： struct ListNode { int m_nKey; ListNode* m_pNext; }; 看到这道题后，很多人的第一反应是从头到尾输出将会比较简单，于是我们很自然地想到把链表中链接节点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。但该方法会改变原来链表的结构。是否允许在打印链表的时候修改链表的结构？这取决于面试官的要求，因此在面试的时候我们要询问清楚面试官的要求。 面试小提示：在面试中，如果我们打算修改输入的数据，则最好先问面试官是不是允许修改。 通常打印是一个只读操作，我们不希望打印时修改内容。假设面试官也要求这个题目不能改变链表的结构。 接下来我们想到解决这个问题肯定要遍历链表。遍历的顺序是从头到尾，可输出的顺序却是从尾到头。也就是说，第一个遍历到的节点最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这种顺序。每经过一个节点的时候，把该节点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出节点的值，此时输出的节点的顺序己经反转过来了。这种思路的实现代码如下： #include \"..\\Utilities\\List.h\" #include void PrintListReversingly_Iteratively(ListNode* pHead) { std::stack nodes; ListNode* pNode = pHead; while(pNode != nullptr) { nodes.push(pNode); pNode = pNode->m_pNext; } while(!nodes.empty()) { pNode = nodes.top(); printf(\"%d\\t\", pNode->m_nValue); nodes.pop(); } } 既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构，于是很自然地又想到了用递归来实现。要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。 基于这样的思路，不难写出如下代码： void PrintListReversingly_Recursively(ListNode* pHead) { if(pHead != nullptr) { if (pHead->m_pNext != nullptr) { PrintListReversingly_Recursively(pHead->m_pNext); } printf(\"%d\\t\", pHead->m_nValue); } } 上面的基于递归的代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一些。更多关于循环和递归的讨论，详见本书的2.4.1节。 剑指 Offer P58，本题完整的源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/06_PrintListInReversedOrder 备案号： -->沪ICP备2022002183号-1 "}}