{"pages/springboot/springandspringboot.html":{"url":"pages/springboot/springandspringboot.html","title":"Spring与SpringBoot","keywords":"","body":"Spring与SpringBoot 23.12.23 20:55开始 23.12.23 23:17更新 23.12.24 22:50更新 Spring的能力 https://spring.io/ Microservices（微服务）：一个项目功能模块很多，将每一个功能模块拆解成一个微小的服务，独立运行。 Reactive（响应式编程）：构建异步数据流，占用少量的线程，少量cpu及内存资源，构建高吞吐量的应用。 Cloud（分布式云开发） Web apps（Web应用）：SpringMVC Serverless（无服务开发）：函数式服务，无需购买服务器。 Event Driver（事件驱动）：实时数据流。 Batch：批处理。 Spring生态圈 https://spring.io/projects/spring-boot/ Spring Framework（Web开发） Spring Data（数据访问） Spring Security（安全控制） Spring Cloud(分布式) Spring Session(分布式Session的存储问题) Spring AMQP（消息队列） Spring Mobile（移动开发） Spring Batch（批处理） Spring Android Spring Shell ...... Spring5升级 响应式编程：https://spring.io/reactive/ 内部源码设计：基于Java8的一些新特性，如：接口默认实现，重新设计源码架构。 接口默认实现：不在需要使用适配器模式。 什么是SpringBoot SpringBoot是整合Spring技术栈的一站式框架。 SpringBoot是简化Spring技术栈的快速开发脚手架。 SpringBoot要求 https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-system-requirements Java8及以上。 Maven3.3及以上。 为什么用SpringBoot Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can \"just run\". 能快速创建出生产级别的Spring应用 SpringBoot优点 Create stand-alone Spring applications 创建独立Spring应用 Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 内嵌web服务器 Provide opinionated 'starter' dependencies to simplify your build configuration 自动starter依赖，简化构建配置 Automatically configure Spring and 3rd party libraries whenever possible 自动配置Spring以及第三方功能 Provide production-ready features such as metrics, health checks, and externalized configuration 提供生产级别的监控、健康检查及外部化配置 Absolutely no code generation and no requirement for XML configuration 无代码生成、无需编写XML SpringBoot缺点 人称版本帝，迭代快，需要时刻关注变化 封装太深，内部原理复杂，不容易精通 微服务 https://martinfowler.com/microservices/ 微服务是一种架构风格 一个应用拆分为一组小型服务 每个服务运行在自己的进程内，也就是可独立部署和升级 服务之间使用轻量级HTTP交互 服务围绕业务功能拆分 可以由全自动部署机制独立部署 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术 分布式 分布式的困难 远程调用：Http方式 服务发现：找到服务可用的机器 负载均衡 服务容错：A服务调用B服务失败，如何处理。 配置管理：建立配置中心，相同服务去配置中心更新。 服务监控：对服务健康状况的监测。 链路追踪：服务A调B服务，B服务调用C服务，C服务出现问题，如何排查。 日志管理 任务调度：服务A有个定时任务，所有机器怎么同步，并发还是串行。 ...... 分布式的解决 SpringBoot + SpringCloud 云原生 原生应用如何上云。 Cloud Native 上云的困难 服务自愈：服务A的一台机器挂了，自动拉起一台新机器，部署服务A。 弹性伸缩：流量高峰自动增加服务部署，流量低峰家少服务器部署。 服务隔离：一台机器同时部署了服务A、B、C，A服务挂了，不影响其他服务。 自动化部署 灰度发布：更新服务只更新其中一台机器，其他机器的服务依然保持旧版本，经过时间验证，更新的服务没有问题，在全部更新。 流量治理：机器A性能不好，让A负载低一些。 ...... 上云的解决 初识云原生 深入Docker-容器化技术 掌握星际容器编排Kubernetes DevOps-实战企业CI/CD，构建企业云平台 拥抱新一代架构Service Mesh与Serverless 云上架构与场景方案实战 如何学习SpringBoot 进入官网：https://spring.io/projects/spring-boot/ 点击LEARN，CURRENT当前版本，xxx-SNAPSHOT快照版本，RELEASE已发布。 点击Reference Doc. Documentation Overview（文档） https://docs.spring.io/spring-boot/docs/current/reference/html/documentation.html#documentation 可以下载PDF Getting Started（入门） Using Spring Boot（使用Spring Boot） Core Features（核心特性） 查看版本更新日志：https://github.com/spring-projects/spring-boot/wiki#release-notes 学习资料 文档地址：https://www.yuque.com/atguigu/springboot 源码地址：https://gitee.com/leifengyang/springboot2 视频地址 start：https://www.bilibili.com/video/BV19K4y1L7MT?p=1 end：https://www.bilibili.com/video/BV19K4y1L7MT?p=4 "},"pages/springboot/gettingstarted.html":{"url":"pages/springboot/gettingstarted.html","title":"SpringBoot入门","keywords":"","body":"SpringBoot入门 23.12.25 2:30更新 官方地址 https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.introducing-spring-boot SpringBoot2系统要求 Java 8 & 兼容java14 . Maven 3.3+ idea 2019.1.2 命令 监测java版本 java -version java version \"1.8.0_361\" Java(TM) SE Runtime Environment (build 1.8.0_361-b09) Java HotSpot(TM) 64-Bit Server VM (build 25.361-b09, mixed mode) 查看maven版本 mvn -v Apache Maven 3.9.3 (21122926829f1ead511c958d89bd2f672198ae9f) Maven home: /Users/chenchangqing/Documents/apps/apache-maven-3.9.3 Java version: 1.8.0_361, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_361.jdk/Contents/Home/jre Default locale: zh_CN, platform encoding: UTF-8 OS name: \"mac os x\", version: \"11.7.10\", arch: \"x86_64\", family: \"mac\" 修改setting.xml 打开Maven home/conf/settings.xml 替换配置文件： nexus-aliyun central Nexus aliyun http://maven.aliyun.com/nexus/content/groups/public jdk-1.8 true 1.8 1.8 1.8 1.8 HelloWorld 打开官方文档 https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.first-application 创建maven的springboot项目 http://1221.site/pages/idea/createp.html#%E4%BD%BF%E7%94%A8maven%E5%88%9B%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AE 1）点击New Project 2）项目设置 3）Create 4）pom.xml 默认会有一个Main入口 @SpringBootApplication public class Springboot01HelloworldApplication { public static void main(String[] args) { SpringApplication.run(Springboot01HelloworldApplication.class, args); } } 创建类HelloController 右键包名，New->Java Class，输入HelloController： @RestController public class HelloController { @RequestMapping(\"/hello\") public String handle01(){ return \"Hello, Spring Boot!\"; } } 运行项目 在Springboot01HelloworldApplication运行main方法： 发现错误 springboot3.2.1不支持jdk1.8，需要更新到java17 配置文件 application.properties https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties 例如：Server Properties -> server.port 简化部署 springboot支持通过.jar文件直接启动服务。官方文档： https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.first-application.executable-jar 配置pom.xml org.springframework.boot spring-boot-maven-plugin 打包 找到jar target->xxx-1.0-SNAPSHOT.jar 运行项目 cd到jar目录，执行： java -jar xxx-1.0-SNAPSHOT.jar xxx-1.0-SNAPSHOT.jar/BOOT-INF/lib：这里目录下有tomcat-embed-core-9.0.38.jar、tomcat-embed-websocket-9.0.38，带有tomcat环境。 视频地址 start：https://www.bilibili.com/video/BV19K4y1L7MT?p=5 end：https://www.bilibili.com/video/BV19K4y1L7MT?p=5 "},"pages/springboot/autoconfig.html":{"url":"pages/springboot/autoconfig.html","title":"自动配置","keywords":"","body":"自动配置 24.1.5 00:21 开始 24.1.5 01:13 更新 24.1.6 19:36 更新 自动版本仲裁机制 在pom.xml文件可以找到以上parent配置： org.springframework.boot spring-boot-starter-parent 2.3.4.RELEASE 点击spring-boot-starter-parent，可以看到： org.springframework.boot spring-boot-dependencies 2.3.4.RELEASE 点击spring-boot-dependencies，可以看到： 5.18.3 2.0.2 2.31.2 1.9.21 3.24.2 ... 1.1.0 2.9.1 3.0.3 在这里声明了几乎所有常用的jar依赖，称为自动版本仲裁机制。 修改mysql默认版本号 点击：https://mvnrepository.com/ 搜索mysql，点击mysql-connector-j，找到需要的版本，比如：5.1.43 修改pom.xml： 5.1.43 org.springframework.boot mysql-connector-java starter场景启动器 官方地址：https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters 官方starter：spring-boot-starter-*。 第三方starter：thirdpartyproject-spring-boot-starter。 只要引入starter，这个场景的所有常规需要的依赖我们都自动引入。 核心依赖： org.springframework.boot spring-boot-starter 2.3.4.RELEASE compile 查看依赖树：右键点击artifactId，点击Diagrams->Show Dependences。 自动配置 在spring-boot-starter-web-3.2.1.pom，自动配置了Tomcatstarter，SpringMVCstarter。 Tomcat org.springframework.boot spring-boot-starter-tomcat 3.2.1 compile SpringMVC org.springframework spring-web 6.1.2 compile org.springframework spring-webmvc 6.1.2 compile 默认包扫描 https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.structuring-your-code.using-the-default-package 默认扫描：主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来。 修改包扫描路径：在Application类上增加注解： @SpringBootApplication(scanBasePackages=\"com.xxx\") 或 @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(\"com.xxx\") 各种配置 tomcat默认端口：server.port 文件上传：spring.servlet.multipart.max-file-size 配置都是绑定了java类，比入文件上传：MultipartProperties，并且这个java类在容器中存在对应对象。 所有配置都可以通过application.properties修改。 配置是按场景starter加载的。 SpringBoot所有自动配置都在spring-boot-autoconfigure`。 点击spring-boot-starter-web，点击spring-boot-starter，找到spring-boot-autoconfigure 视频地址 start：https://www.bilibili.com/video/BV19K4y1L7MT/?p=6 end：https://www.bilibili.com/video/BV19K4y1L7MT/?p=7 "},"pages/springboot/annotation.html":{"url":"pages/springboot/annotation.html","title":"注解","keywords":"","body":"注解 24.1.6 19:38 开始 24.1.6 21:13 更新 @Configuration 告诉SpringBoot这是一个配置类，相当于配置文件。 @Configuration public class MyConfig {} proxyBeanMethods属性 Full(proxyBeanMethods=true)：保证每个@Bean方法被调用多少次返回的组件都是单实例的。 Lite(proxyBeanMethods=false)：每个@Bean方法被调用多少次返回的组件都是新创建的。 组件依赖必须使用Full模式，默认就是这个模式。 @Configuration(proxyBeanMethods = false) public class MyConfig {} 不需要组件依赖时使用Lite模式，也就是说不需要创建新组件时使用Lite，使用Full模式来保证取得的组件为ioc中的同一组件，而这两个模式在getBean时都是从ioc容器中拿的同一个组件。 @Bean 给容器中添加组件，以方法名作为组件的id，返回类型就是组件类型； 返回的值，就是组件在容器中的实例，默认单实例。 @Configuration public class MyConfig { @Bean public User user01(){ User zhangsan = new User(\"zhangsan\", 18); return zhangsan; } } 注册依赖 @Configuration public class MyConfig { @Bean public User user01(){ User zhangsan = new User(\"zhangsan\", 18); zhangsan.setPet(tomcatPet()); return zhangsan; } @Bean(\"tom\") public Pet tomcatPet(){ return new Pet(\"tomcat\"); } } SpringMVC注解 @Component、@Controller、@Service、@Repository 根据它们的源码可以看到，Controller、Service、Repository其本质就是Component。 它存在的本质只是给开发者看的，对Spring而言它们就都是Component。 @Controller 控制层类，@Service 业务层类，@Repository 持久层类。 @Component 无法归类到前3种时就称为组件。 原文：https://blog.csdn.net/nutony/article/details/118670662 @Import 给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名。 @Import({User.class, DBHelper.class}) @Configuration(proxyBeanMethods = false) public class MyConfig {} @Import 高级用法： https://www.bilibili.com/video/BV1gW411W7wy?p=8 @Conditional 该注解及其扩展来的注解的关键是实现Condition接口重写其matches方法。 @Conditional，中派生了很多的子注解，它们可以添加在@Bean注解的方法上也可以放在配置类上，在方法上满足所需条件时则执行方法中内容并注册到IOC。 容器中如果不满足条件则不注册，在配置类中满足需求时则执行配置类中所有的@Bean方法并注册到 IOC。 容器中如果不满足条件则不注册，以@ConditionalOnBean(name=\"tom\")为例，当 IOC 容器中拥有id为tom的组件时才会满足条件，否则不满足条件。 @Configuration(proxyBeanMethods = false) public class MyConfig { @Bean @ConditionalOnBean(name = \"tom\") //@ConditionalOnMissingBean(name = \"tom\") public User user01(){ User zhangsan = new User(\"zhangsan\", 18); return zhangsan; } @Bean(\"tom\") public Pet tomcatPet(){ return new Pet(\"tomcat\"); } } @ImportResource 配置文件： ======================beans.xml========================= 加载配置文件： @ImportResource(\"classpath:beans.xml\") public class MyConfig {} 测试： boolean haha = run.containsBean(\"haha\"); boolean hehe = run.containsBean(\"hehe\"); System.out.println(\"haha：\"+haha);//true System.out.println(\"hehe：\"+hehe);//true 配置绑定 原始方式 public class getProperties { public static void main(String[] args) throws FileNotFoundException, IOException { Properties pps = new Properties(); pps.load(new FileInputStream(\"a.properties\")); Enumeration enum1 = pps.propertyNames();//得到配置文件的名字 while(enum1.hasMoreElements()) { String strKey = (String) enum1.nextElement(); String strValue = pps.getProperty(strKey); System.out.println(strKey + \"=\" + strValue); //封装到JavaBean。 } } } 第一种方式 @Component + @ConfigurationProperties：@Component@ConfigurationProperties(prefix = \"mycar\")声明在要绑定的类的上方。 /** * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能 */ @Component @ConfigurationProperties(prefix = \"mycar\") public class Car { private String brand; private Integer price; public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public Integer getPrice() { return price; } public void setPrice(Integer price) { this.price = price; } @Override public String toString() { return \"Car{\" + \"brand='\" + brand + '\\'' + \", price=\" + price + '}'; } } 第二种方式 @EnableConfigurationProperties + @ConfigurationProperties： @ConfigurationProperties(prefix = \"mycar\")声明在要绑定的类的上方； 在配置类的上方声明@EnableConfigurationProperties(Car.class)，开启对应类的配置绑定功能，把Car这个组件自动注入到容器中。 @EnableConfigurationProperties(Car.class) // 1、开启Car配置绑定功能 // 2、把这个Car这个组件自动注册到容器中 // 说明一下为什么需要第二种方法： // 如果@ConfigurationProperties是在第三方包中， // 那么@component是不能注入到容器的， // 只有@EnableConfigurationProperties才可以注入到容器。 public class MyConfig {} 视频地址 start：https://www.bilibili.com/video/BV19K4y1L7MT/?p=8 start：https://www.bilibili.com/video/BV19K4y1L7MT/?p=12 "},"pages/springboot/autoconfigprinciple.html":{"url":"pages/springboot/autoconfigprinciple.html","title":"自动配置原理","keywords":"","body":"自动配置原理 24.1.6 21:59 开始 24.1.7 00:39 更新 @SpringBootApplication @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) @SpringBootConfiguration：也就是@Configuration，代表当前是一个配置类。 @ComponentScan：指定扫描哪些。 @EnableAutoConfiguration：激活自动配置。 @AutoConfigurationPackage// 下面分析 @Import({AutoConfigurationImportSelector.class})// 下面分析 public @interface EnableAutoConfiguration @AutoConfigurationPackage // 给容器中导入一个组件 @Import({AutoConfigurationPackages.Registrar.class}) public @interface AutoConfigurationPackage 利用Registrar给容器中导入一系列组件。 指定的一个包下的所有组件导入进来，默认xxxApplication所在包下。 Registrar： static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports { Registrar() { } public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0])); } public Set determineImports(AnnotationMetadata metadata) { return Collections.singleton(new PackageImports(metadata)); } } metadata：注解元信息，注解指的是@AutoConfigurationPackage。 @AutoConfigurationPackage是标注在xxxApplication类上。 计算包名：new PackageImports(metadata)).getPackageNames() 所以Registrar将xxxAplication所在包下的所有组件注册了。 @Import @Import({AutoConfigurationImportSelector.class}) public class AutoConfigurationImportSelector { ... @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } ... } 调用关系 利用getAutoConfigurationEntry(annotationMetadata)给容器中批量导入一些组件。 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); // 寻找需要加载的候选配置类数组 List configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } 调用getCandidateConfigurations，获取到所有需要导入到容器中的配置类。 List configurations = getCandidateConfigurations(annotationMetadata, attributes); Debug调试，查看有127个候选配置组件： getCandidateConfigurations getCandidateConfigurations调用了ImportCandidates.load： protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()) .getCandidates(); Assert.notEmpty(configurations, \"No auto configuration classes found in \" + \"META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } ImportCandidates.load从META-INF/spring/%s.imports位置来加载一个文件： public static ImportCandidates load(Class annotation, ClassLoader classLoader) { Assert.notNull(annotation, \"'annotation' must not be null\"); ClassLoader classLoaderToUse = decideClassloader(classLoader); String location = String.format(\"META-INF/spring/%s.imports\", annotation.getName()); Enumeration urls = findUrlsInClasspath(classLoaderToUse, location); List importCandidates = new ArrayList(); while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); importCandidates.addAll(readCandidateConfigurations(url)); } return new ImportCandidates(importCandidates); } 查看spring-boot-autoconfigure-3.2.1jar的META-INF: spring.boot2.7起使用META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件来指定需要加载自动配置类 按需开启自动配置项 虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration 按照条件装配规则（@Conditional），最终会按需配置。 AopAutoConfiguration // 我是一个配置类 @AutoConfiguration // 判断配置文件中是否存在“spring.aop”，且名字为“auto”，且值为true，则配置类生效； // matchIfMissing = true：如果没有配，也认为配置了，并且值为true，所以默认不配也是生效。 @ConditionalOnProperty(prefix = \"spring.aop\", name = \"auto\", havingValue = \"true\", matchIfMissing = true) public class AopAutoConfiguration { // 我是一个配置类 @Configuration(proxyBeanMethods = false) // 如果整个应用没有`Advice`类（org.aspectj.weaver.Advice），则不生效； // 默认没有`Advice`类，所以默认不生效。 @ConditionalOnClass(Advice.class) static class AspectJAutoProxyingConfiguration { ... } @Configuration(proxyBeanMethods = false) // 如果没有“org.aspectj.weaver.Advice”类，则生效； // 默认是没有的，所有默认生效。 @ConditionalOnMissingClass(\"org.aspectj.weaver.Advice\") // 默认开启aop功能 @ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"true\", matchIfMissing = true) static class ClassProxyingConfiguration { ... } } CacheAutoConfiguration @AutoConfiguration(after = { CouchbaseDataAutoConfiguration.class, HazelcastAutoConfiguration.class, HibernateJpaAutoConfiguration.class, RedisAutoConfiguration.class }) // 判断是否存在`CacheManager.class`类，不存在，则不生效； // 默认是有的，条件通过； @ConditionalOnClass(CacheManager.class) // 默认是没有的，条件不通过，配置不生效。 @ConditionalOnBean(CacheAspectSupport.class) @ConditionalOnMissingBean(value = CacheManager.class, name = \"cacheResolver\") @EnableConfigurationProperties(CacheProperties.class) @Import({ CacheConfigurationImportSelector.class, CacheManagerEntityManagerFactoryDependsOnPostProcessor.class }) public class CacheAutoConfiguration { ... } DispatcherServletAutoConfiguration @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) // 判断是否在`ServletWebServerFactoryAutoConfiguration`配置完成之后 @AutoConfiguration(after = ServletWebServerFactoryAutoConfiguration.class) // 判断是否是原生servlet的应用，还有一种是响应式编程`WebFlux` @ConditionalOnWebApplication(type = Type.SERVLET) // 判断是否导入了`DispatcherServlet`类，因为注册了springmvc的starter，所以导入了。 @ConditionalOnClass(DispatcherServlet.class) public class DispatcherServletAutoConfiguration { ... @Configuration(proxyBeanMethods = false) @Conditional(DefaultDispatcherServletCondition.class) // 判断是否导入`ServletRegistration` @ConditionalOnClass(ServletRegistration.class) // 开启配置绑定功能，配置文件中以“spring.mvc”开头的属性， // 会被绑定至`WebMvcProperties`实例。 @EnableConfigurationProperties(WebMvcProperties.class) protected static class DispatcherServletConfiguration { // 配置`DispatcherServlet`组件，指定名字。 @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) { ... return dispatcherServlet; } @SuppressWarnings({ \"deprecation\", \"removal\" }) private void configureThrowExceptionIfNoHandlerFound(WebMvcProperties webMvcProperties, DispatcherServlet dispatcherServlet) { dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound()); } // 配置文件上传解析器组件 @Bean @ConditionalOnBean(MultipartResolver.class) // 容器中没有名字为“multipartResolver”的组件 @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) public MultipartResolver multipartResolver(MultipartResolver resolver) { // 给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。 // SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范 // Detect if the user has created a MultipartResolver but named it incorrectly return resolver; } } ... } HttpEncodingAutoConfiguration @AutoConfiguration // 配置绑定至`ServerProperties`类 @EnableConfigurationProperties(ServerProperties.class) // 是否是Servlet应用 @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) // 是否存在`CharacterEncodingFilter`类 @ConditionalOnClass(CharacterEncodingFilter.class) // 默认开启encoding @ConditionalOnProperty(prefix = \"server.servlet.encoding\", value = \"enabled\", matchIfMissing = true) public class HttpEncodingAutoConfiguration { private final Encoding properties; public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } @Bean // 容器中如果没有配CharacterEncodingFilter，自动配置 // SpringBoot默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE)); return filter; } ... } 总结 SpringBoot先加载所有的自动配置类（xxxxxAutoConfiguration）。 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。 xxxxProperties里面拿，xxxProperties和配置文件进行了绑定。 生效的配置类就会给容器中装配很多组件。 只要容器中有这些组件，相当于这些功能就有了。 定制化配置 用户直接自己@Bean替换底层的组件。 用户去看这个组件是获取的配置文件什么值就去修改。 xxxxxAutoConfiguration ---> 组件 ---> xxxxProperties里面拿值 ----> application.properties 视频地址 start：https://www.bilibili.com/video/BV19K4y1L7MT?p=13 end：https://www.bilibili.com/video/BV19K4y1L7MT?p=15 "},"./":{"url":"./","title":"最近更新","keywords":"","body":"自动配置原理 24.1.6 21:59 开始 24.1.7 00:39 更新 @SpringBootApplication @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) @SpringBootConfiguration：也就是@Configuration，代表当前是一个配置类。 @ComponentScan：指定扫描哪些。 @EnableAutoConfiguration：激活自动配置。 @AutoConfigurationPackage// 下面分析 @Import({AutoConfigurationImportSelector.class})// 下面分析 public @interface EnableAutoConfiguration @AutoConfigurationPackage // 给容器中导入一个组件 @Import({AutoConfigurationPackages.Registrar.class}) public @interface AutoConfigurationPackage 利用Registrar给容器中导入一系列组件。 指定的一个包下的所有组件导入进来，默认xxxApplication所在包下。 Registrar： static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports { Registrar() { } public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0])); } public Set determineImports(AnnotationMetadata metadata) { return Collections.singleton(new PackageImports(metadata)); } } metadata：注解元信息，注解指的是@AutoConfigurationPackage。 @AutoConfigurationPackage是标注在xxxApplication类上。 计算包名：new PackageImports(metadata)).getPackageNames() 所以Registrar将xxxAplication所在包下的所有组件注册了。 @Import @Import({AutoConfigurationImportSelector.class}) public class AutoConfigurationImportSelector { ... @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } ... } 调用关系 利用getAutoConfigurationEntry(annotationMetadata)给容器中批量导入一些组件。 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); // 寻找需要加载的候选配置类数组 List configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } 调用getCandidateConfigurations，获取到所有需要导入到容器中的配置类。 List configurations = getCandidateConfigurations(annotationMetadata, attributes); Debug调试，查看有127个候选配置组件： getCandidateConfigurations getCandidateConfigurations调用了ImportCandidates.load： protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()) .getCandidates(); Assert.notEmpty(configurations, \"No auto configuration classes found in \" + \"META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } ImportCandidates.load从META-INF/spring/%s.imports位置来加载一个文件： public static ImportCandidates load(Class annotation, ClassLoader classLoader) { Assert.notNull(annotation, \"'annotation' must not be null\"); ClassLoader classLoaderToUse = decideClassloader(classLoader); String location = String.format(\"META-INF/spring/%s.imports\", annotation.getName()); Enumeration urls = findUrlsInClasspath(classLoaderToUse, location); List importCandidates = new ArrayList(); while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); importCandidates.addAll(readCandidateConfigurations(url)); } return new ImportCandidates(importCandidates); } 查看spring-boot-autoconfigure-3.2.1jar的META-INF: spring.boot2.7起使用META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件来指定需要加载自动配置类 按需开启自动配置项 虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration 按照条件装配规则（@Conditional），最终会按需配置。 AopAutoConfiguration // 我是一个配置类 @AutoConfiguration // 判断配置文件中是否存在“spring.aop”，且名字为“auto”，且值为true，则配置类生效； // matchIfMissing = true：如果没有配，也认为配置了，并且值为true，所以默认不配也是生效。 @ConditionalOnProperty(prefix = \"spring.aop\", name = \"auto\", havingValue = \"true\", matchIfMissing = true) public class AopAutoConfiguration { // 我是一个配置类 @Configuration(proxyBeanMethods = false) // 如果整个应用没有`Advice`类（org.aspectj.weaver.Advice），则不生效； // 默认没有`Advice`类，所以默认不生效。 @ConditionalOnClass(Advice.class) static class AspectJAutoProxyingConfiguration { ... } @Configuration(proxyBeanMethods = false) // 如果没有“org.aspectj.weaver.Advice”类，则生效； // 默认是没有的，所有默认生效。 @ConditionalOnMissingClass(\"org.aspectj.weaver.Advice\") // 默认开启aop功能 @ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"true\", matchIfMissing = true) static class ClassProxyingConfiguration { ... } } CacheAutoConfiguration @AutoConfiguration(after = { CouchbaseDataAutoConfiguration.class, HazelcastAutoConfiguration.class, HibernateJpaAutoConfiguration.class, RedisAutoConfiguration.class }) // 判断是否存在`CacheManager.class`类，不存在，则不生效； // 默认是有的，条件通过； @ConditionalOnClass(CacheManager.class) // 默认是没有的，条件不通过，配置不生效。 @ConditionalOnBean(CacheAspectSupport.class) @ConditionalOnMissingBean(value = CacheManager.class, name = \"cacheResolver\") @EnableConfigurationProperties(CacheProperties.class) @Import({ CacheConfigurationImportSelector.class, CacheManagerEntityManagerFactoryDependsOnPostProcessor.class }) public class CacheAutoConfiguration { ... } DispatcherServletAutoConfiguration @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE) // 判断是否在`ServletWebServerFactoryAutoConfiguration`配置完成之后 @AutoConfiguration(after = ServletWebServerFactoryAutoConfiguration.class) // 判断是否是原生servlet的应用，还有一种是响应式编程`WebFlux` @ConditionalOnWebApplication(type = Type.SERVLET) // 判断是否导入了`DispatcherServlet`类，因为注册了springmvc的starter，所以导入了。 @ConditionalOnClass(DispatcherServlet.class) public class DispatcherServletAutoConfiguration { ... @Configuration(proxyBeanMethods = false) @Conditional(DefaultDispatcherServletCondition.class) // 判断是否导入`ServletRegistration` @ConditionalOnClass(ServletRegistration.class) // 开启配置绑定功能，配置文件中以“spring.mvc”开头的属性， // 会被绑定至`WebMvcProperties`实例。 @EnableConfigurationProperties(WebMvcProperties.class) protected static class DispatcherServletConfiguration { // 配置`DispatcherServlet`组件，指定名字。 @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME) public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) { ... return dispatcherServlet; } @SuppressWarnings({ \"deprecation\", \"removal\" }) private void configureThrowExceptionIfNoHandlerFound(WebMvcProperties webMvcProperties, DispatcherServlet dispatcherServlet) { dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound()); } // 配置文件上传解析器组件 @Bean @ConditionalOnBean(MultipartResolver.class) // 容器中没有名字为“multipartResolver”的组件 @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) public MultipartResolver multipartResolver(MultipartResolver resolver) { // 给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。 // SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范 // Detect if the user has created a MultipartResolver but named it incorrectly return resolver; } } ... } HttpEncodingAutoConfiguration @AutoConfiguration // 配置绑定至`ServerProperties`类 @EnableConfigurationProperties(ServerProperties.class) // 是否是Servlet应用 @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) // 是否存在`CharacterEncodingFilter`类 @ConditionalOnClass(CharacterEncodingFilter.class) // 默认开启encoding @ConditionalOnProperty(prefix = \"server.servlet.encoding\", value = \"enabled\", matchIfMissing = true) public class HttpEncodingAutoConfiguration { private final Encoding properties; public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } @Bean // 容器中如果没有配CharacterEncodingFilter，自动配置 // SpringBoot默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE)); return filter; } ... } 总结 SpringBoot先加载所有的自动配置类（xxxxxAutoConfiguration）。 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。 xxxxProperties里面拿，xxxProperties和配置文件进行了绑定。 生效的配置类就会给容器中装配很多组件。 只要容器中有这些组件，相当于这些功能就有了。 定制化配置 用户直接自己@Bean替换底层的组件。 用户去看这个组件是获取的配置文件什么值就去修改。 xxxxxAutoConfiguration ---> 组件 ---> xxxxProperties里面拿值 ----> application.properties 视频地址 start：https://www.bilibili.com/video/BV19K4y1L7MT?p=13 end：https://www.bilibili.com/video/BV19K4y1L7MT?p=15 备案号： -->沪ICP备2022002183号-1 "}}