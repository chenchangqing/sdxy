{"./":{"url":"./","title":"最近更新","keywords":"","body":"常用链接 iOS·问题汇总 UITextField PlaceHolder居中显示问题 iOS 10、设置导航栏全透明 两种iOS隐藏导航栏的正确方法 让超出父视图范围的子视图响应事件，在UIView范围外响应点击 iOS时间的处理 ios 消除 字符串 首尾空格 iOS优美的侧滑返回FDFullscreenPopGesture iOS 设置屏幕常亮，延长休眠时间 arm64、armv7、armv7s iOS获取手机型号 Cannot find protocol definition for XXX ios – 奇怪的UIView-Encapsulated-Layout-Height错误 fix:iOS 13.1.3,textView点击回调3次 \"Double-quoted\" issue in latest version of Firebase rem布局在webview中页面错乱解决办法 解決UIWebView target = '_blank'不能彈出 Cocoapod with optional subspecs is not installing, if subspecs in the Podfile and another dependent Cocoapod podspec doesn't match Can I have an init func in a protocol? 构造方法不触发didSet iOS9中调用其他APP时出现This app is not allowed to query 微信怎么唤起app? facebook链接中分享的图片 line链接中分享的图片 Swift - encode URL Class Only Protocols In Swift 5 git删除远程分支报错:remote ref does not exist ERROR | [iOS] unknown: Encountered an unknown error (/usr/bin/xcrun simctl list -j devices Mac解疑：处理 Adobe Genuine Software Integrity Service assigning to ‘NSString *_strong’ from ‘const NSString’ discards qualifiers iOS10 NSLog限制为1024个字符字符串 Auto property synthesis will not synthesize property ‘delegate’;it will be implemented by its superc NSPredicate 谓词 更改 macOS 用户帐户和个人文件夹的名称 苹果 iOS 13 新增的 sign with Apple API 是如何实现隐私保护的？ Xcode 11新建项目多了Scenedelegate 使用 Xcode 13.2.1 和 iOS 15.4 设备 圆角和阴影并存（Swift和OC） Swiftlint warning : For Where Violation: where clauses are preferred over a single if inside a for. (for_where) 【ios】_UITemporaryLayoutWidth是什麼，為什麼它打破了我的約束？ Git 提交错了不用慌，这三招帮你修改记录 解决Xcode14 pod签名问题 iOS UILabel 添加查看更多 UILabel中的NSAttributedString尾部截断 ScrollView嵌套 iOS开发实战 - 解决UIScrollView嵌套滑动手势冲突 LYEmbedScrollView JXCategoryView MXParallaxHeader 关于嵌套滚动现实的讨论 iOS·新知识 使用 Swift Package Manager 集成依赖库 Swift化零为整：Reduce方法详解 swift3.0中fileprivate，private使用 Swift与泛型编程第四弹：类型擦除 iOS 插件化开发(动态库研究) 在 iOS 上下载文件 iOS归档看这篇就够了 ios - Swift URL查询字符串获取参数 Swift打印变量内存地址 swift小知识点之打印对象的地址 Swift 如何声明某个属性已过期 swift5.0 字符串截取 iOS开发之字符串(NSString)的拼接 iOS - NSDate分类-判断时间是否为今天,昨天,一周内,年月日 IOS 保留小数点后几位 Swift开发小技巧系列 - 浮点型数据的四舍五入 UIPresentationController简介 不要用子类！Swift的核心是面向协议 APP速度优化--启动优化 Swift只有上半部分圆角View XCode模拟器屏幕录制/录屏 UIView的autoresizingMask 关于Swift：如何对数组进行分组 SnapKit 关于数组Array的扩展—— 自适应宽度、垂直、水平、九宫格布局 do while妙用 iOS中取消延迟执行函数 iOS 阿拉伯语 RTL适配 Swift - 实现图片（UIImage）的水平翻转(镜像)，垂直翻转 UIView动画 Swift 图片拉伸，屡试不爽！！！ 为什么我们应该避免在 Swift 结构中使用闭包？ CocoaPods清理本地缓存 ExclusiveTouch 自定义模板 iOS 高效开发之 - 3分钟实现自定义 Xcode 初始化的模板 Xcode 自定义模板 iOS·审核 检查iOS项目中是否还有使用UIWebView iOS APP内测邀请之TestFlight iOS·多线程 实现自定义NSOperation 开始使用Operation Queue吧 iOS开发 自定义NSOPeration NSOperation property overrides (isExecuting / isFinished) 并发教程 iOS 多线程 - Operation iOS·性能优化 iOS 关于后台持续运行 iOS性能优化 iOS按钮倒计时在进入后台不继续计时的处理 iOS 后台数据处理 background fetch 动画 iOS动画事物（CATransaction） 工具 熊猫压缩 远程 udid获取 JSON格式化 代码格式化插件 App图标在线制作 压缩一个PDF文件 UIImage 二分压缩图片 Woodpecke‪r‬ 图片裁剪 临时邮箱、临时邮、临时电子邮箱、24小时邮箱 JSON格式化 Woodpecker使用 Xcode自定义代码块 时间戳cuo google play store 颜色代码表 阿里网盘资源 在线工具 Gitbook 新版gitbook导出pdf gitbook教程 推荐12个实用的gitbook插件 mermaid插件 mermaid-gb3 mermaid文档 GitBook 插件 PlantUML 简介 GitBookW3C Gitbook详解（四）-配置和说明详解 定义右面页面的宽度 npmjs GitBook 本地使用排雷，及导出基本可用的 PDF 版本 案例 Markdown 用 Markdown 制作简历 Markdown Guide MarkDown代码块高亮 在 markdown 中生成并导出思维导图的 Gitbook 插件 gitbook 3.2.3及之后流程图解决方案 Markdown 中文文档 markdown编辑 学生、工作人士如何才能更优雅地记笔记、写文档?（Markdown教程，详细到超乎你想象） 使用 Markdown 时，如何为文字加下划线？ Markdown 简介 MarkDown中如何换行？ 简历 iOS程序员简历模板 好看的博客 bawn YouXianMing 笑忘书店 Cocoapods CocoaPods安装方法-2020.05.25 XCode 10中修改cocoapods中的源码编译不生效的解决方法 Cocoapods整理（三）——编写podspec文件 装机步骤 iOS 安装CocoaPods Mac系统如何显示隐藏文件 临时解决GitHub的raw.githubusercontent.com无法连接问题 Mac安装git，brew出现的问题 macos如何科学的安装homebrew跟npm? 安装brew的正确姿势 GitBook 安装以及使用 mac管理及更新node版本 安装Gitbook mac软件网址 xcode下载 开源项目 iOSExperience functionList GitBook 上有哪些十分优秀的已经完成的书？ 滴滴的哆啦A梦组件 iOS 打点 闪屏demo QGTextField URLNavigator 网络监控 Swift-30-Projects iOSKeyPointExploration 语法糖 TTBaseUIKit GAppFramework SwiftTheme NerdyUI Tangram-iOS YNSearch IOS网络请求的简单封装设计 YTKNetwork QMUI_iOS 代码分类 好库编程网 SDUserDefaults LCHelper geniusDemo 2018 iOS 三方库(仅供方面查看) macos 12.3.1 Xcode 13.3 最新objc 838源码更新 国家icon Stevia MVVM MVVMReactiveCocoa BigShow1949 Monkey MHDevelopExample_Objective_C MVVMDemo 地图 map BMKLocationKit iOS在APP中调用第三方地图地图（苹果,高德，百度，腾讯） 经纬度查询 学习 尚德 自考 苹果官方教程swiftui 潭州课堂 swift51 csdn 苹果官方文档 苹果官方文档-cn 苹果官方文档-en ios-resolution 查询序列号 SwiftUI SwiftUI-api SwiftUI-tutorials SwiftUI-互动教程 SwiftUI 基础之05 list 和 searchbar (2020) SwiftUI教程与源码 SwiftUI Search Bar in the Navigation Bar UISearchController Tutorial OpenGL iOS-OpenGL-Tutorials OpenGLES RxSwift Swift - RxSwift的使用详解1（基本介绍、安装配置） RxSwift的学习之路（二）——Subjects 使用 RxTest 来建立基于 RxSwift 的自动化测试 RxSwift中文文档 RxSwift学习 - share(replay:scope:) RXSwift中Driver的使用 RxSwift+Moya网络请求之项目实战 RxMultiCounter RxSwift Error Handling RxDataSource 使用套路与解释 RxSwift 中的老司机 面试 iOS开发中 weak和assign的区别 做了快5年iOS，这份面试题让我从15K变成了30K 《招聘一个靠谱的iOS》面试题参考答案 iOS性能优化 iOS]NSHashTable和NSMapTable用法 Swift中的unowned和weak VPN cx vpn·周 vpn·李 有免费的梯子软件 导航栏 iOS系统中导航栏的转场解决方案与最佳实践 IOS-FDFullscreenPopGesture的使用 我的iOS开发笔记——右滑返回手势失效怎么办？ iOS 导航栏的那些事儿 Swift - 导航栏滑动透明渐变效果的实现（透明度随视图滚动而改变） iOS·UI 详解intrinsicContentSize 及 约束优先级／content Hugging／content Compression Resistance iOS开发笔记常用工具之文本宽度和高度计算 iOS 获取webview高度小结 iOS Swift 判断手机机型 已更新 至iPhone12 iOS判断刘海屏幕机型 所有机型 iOS 设置圆角、指定位置圆角及 iOS 11圆角设置 iOS9 Programming - Autolayout (I) 脚本 sudo pip install openpyxl 快捷键 注释：command+option+/ 打开xcode文档：command+shift+0 现在在Xcode中切换标签的快捷方式？ Flutter Flutter 开发文档 其它 医院等级查询 快速记 shell Shell 函数 shell脚本中判断上一个命令是否执行成功 shell bash判断文件或文件夹是否存在 shell脚本：删除当前目录下除了某几个文件之外的其他文件 ruby Ruby 教程 webview缓存 iOS html5使用缓存并及时更新方案总结 Cache-control iOS webView缓存，保证加载最新html iOS: 聊聊 UIWebView 缓存 H5 和移动端 WebView 缓存机制解析与实战 iOS-WKWebView缓存并保证实时性 iOS代码混淆工具 webview开启无图 iOS定制NSURLProtocol实现离线缓存 web离线技术原理 iOS 开发中使用 NSURLProtocol 拦截 HTTP 请求 使用 NSURLProtocol 拦截 APP 内的网络请求 移动 H5 首屏秒开优化方案探讨 JWNetAutoCache tableView https://www.jianshu.com/p/af4bc69839d8 优化UITableViewCell高度计算的那些事 代码规范 《Effective Objective-C》干货三部曲（二）：规范篇 Swift 如何声明某个属性已过期 单元测试 iOS 单元测试--异步测试 OC实现类似泛型效果的json数据解析 架构 iOS应用架构谈 网络层设计方案 iOS - AFNetWorking打印请求时的相关信息 一键登录 IOS客户端接入 gcd iOS GCD处理多个网络请求并发问题 iOS-GCD的串行队列和并行队列的任务及实现 iOS GCD线程同步以及AFNetworking多次请求线程依赖 c++ C++ 中的 inline 用法 在字符串string中实现一个判断函数，该函数功能是统计某一字符串类对象(仅由单词和空格组成)有多少个单词 IM聊天 环信·IM 环信·iOS SDK 快速集成 环信·集成 iOS SDK 前的准备工作 电影 你的名字 后端 docker 腾讯云 算法 算法学习笔记（目录） 菜鸟算法 Swift - Codable Swift - Codable使用小记 Swift - Codable textview iOS开发－UITextView文字排版 UITextView换行问题解决办法 android studio 用户指南 阿语适配 iOS 国际化 - 阿拉伯语的RTL 踩坑心得 Working with Unicode code points in Swift Swift进阶九:字符串 完整的Unicode地址 iOS检测字符串的语言（用于翻译之前检测） Detect Language of NSString 解决关于swift的Array repeating 初始化多个对象问题 简历优化 iOS开发求职者，写一份成功的简历？ 7年iOS开发经验，教你写一份脱颖而出的简历，进入大厂机会翻3倍！ 怎么样在简历中体现出自己的能力与价值? IOS开发工程师简历范文，【工作经历+项目经验+自我评价】怎么写 iOS高级面试简历指导 备案号： -->沪ICP备2022002183号-1 "},"pages/面试题/取东西.html":{"url":"pages/面试题/取东西.html","title":"取东西","keywords":"","body":"取东西 测试一下 // 初始化每行数量 var row1Count = 3; var row2Count = 5; var row3Count = 7; // 获取行剩余数量 function getRemainCount(rowNum) { switch(parseInt(rowNum)) { case 1: return row1Count; case 2: return row2Count; case 3: return row3Count; default: return 0; } } // 更新行数量 // rowNum: 第几行（1,2,3） // getCount: 取数量 function updateRemainCount(rowNum, getCount) { switch(parseInt(rowNum)) { case 1: row1Count -= getCount; break; case 2: row2Count -= getCount; break; case 3: row3Count -= getCount; break; default: break; } }; // 判断是否取完所有 function judgeFinish() { return (row1Count + row2Count + row3Count) 0) { if (getCount > remainCount) { return -3;// 第x行数量不足 } else { // 更新行数量 updateRemainCount(rowNum, getCount); // 判断是否取完 if (judgeFinish()) { return -1;// 你是输家 } return 0;// 成功取出 } } else { return -2;// 第x行空 } } // 执行回合 // getCount: 取数量 // rowNum: 第几行（1,2,3） function round(rowNum, getCount) { var result = getThing(rowNum, getCount); switch(result) { case 0: alert(\"成功取出\"); break; case -1: alert(\"你是输家\"); break; case -2: alert(\"第\"+rowNum+\"行空\"); break; case -3: alert(\"第\"+rowNum+\"行数量不足\"); break; default: break; } }; // 运行 function run() { var rowNum = prompt(\"取第几行:\",\"\"); var getCount = prompt(\"取多少:\",\"\"); round(rowNum, getCount); } 15个任意物品（可以是火柴牙签poker） 以下按牙签为例 将15根牙签 分成三行 每行自上而下（其实方向不限）分别是3、5、7根 安排两个玩家，每人可以在一轮内，在任意行拿任意根牙签，但不能跨行 拿最后一根牙签的人即为输家 题目 请用你最擅长的语言，以你觉得最优雅的方式写一个符合以上游戏规则的程序。完成后把写好的代码和简历同时发到以下邮箱（备注姓名+岗位），并加上一段简短的文字描述一下你的想法 （请使用javascript，typescript或C#的其中一种语言完成测试题） "},"pages/面试题/sizeof.html":{"url":"pages/面试题/sizeof.html","title":"sizeof","keywords":"","body":"sizeof 面试官：定义一个空的类型，里面没有任何成员变量和成员函数。对 该类型求sizeof，得到的结果是多少？应聘者：答案是1。 面试官：为什么不是0？应聘者：空类型的实例中不包含任何信息，本来求sizeof应该是0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。在Visual Studio中，每个空类型的实例占用1字节的空间。 面试官：如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof,得到的结果又是多少？应聘者：和前面一样，还是1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数而在实例内添加任何额外的信息。 面试官：那如果把析构函数标记为虚函数呢？应聘者：C+的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，一个指针占4字节的空间，因此求sizeof得到4；如果是64位的机器，则一个指针占8字节的空间，因此求sizeof得到8。 测试代码： #include using namespace std; class X { }; class Y: public virtual X { }; class Z: public virtual X { }; class A: public Y, public Z { }; int main() { int x = 0; x = sizeof(X); cout 在Xcode上的执行结果： x：1 y：8 z：8 a：16 参考链接：https://blog.csdn.net/zhuiqiuzhuoyue583/article/details/92846054 "},"pages/面试题/复制构造函数.html":{"url":"pages/面试题/复制构造函数.html","title":"复制构造函数","keywords":"","body":"复制构造函数 比如，面试官递给应聘者一张有如下代码的A4打印纸要求他分析编译运行的结果，并提供3个选项：A.编译错误；B.编译成功，运行时程序崩溃；C.编译运行正常，输出10。 在上述代码中，复制构造函数A(A other)传入的参数是A的一个实例。由于是传值参数，我们把形参复制到实参会调用复制构造函数。因此，如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永无休止的递归调用从而导致栈溢出。因此，C+的标准不允许复制构造函数传值参数，在Visual Studio和GCC中，都将编译出错。要解决这个问题，我们可以把构造函数修改为A(const A&other),也就是把传值参数改成常量引用。 "},"pages/面试题/赋值运算符函数.html":{"url":"pages/面试题/赋值运算符函数.html","title":"赋值运算符函数","keywords":"","body":"赋值运算符函数 题目：如下为类型CMyString的声明，请为该类型添加赋值运算符函数。 class CMyString { public: CMyString(char* pData = nullptr); CMyString(const CMyString& str); ~CMyString(void); CMyString& operator = (const CMyString& str); void Print(); private: char* m_pData; }; 当面试官要求应聘者定义一个赋值运算符函数时，他会在检查应聘者写出的代码时关注如下几点： 是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)。只有返回一个引用，才可以允许连续赋值。否则，如果函数的返回值是void,则应用该赋值运算符将不能进行连续赋值。假设有3个CMyString的对象：strl、str2和str3,在程序中语句str1=str2=str3将不能通过编译。 是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数。把参数声明为引用可以避免这样的无谓消耗，能提高代码的效率。同时，我们在赋值运算符函数内不会改变传入的实例的状态，因此应该为传入的引用参数加上const关键字。 是否释放实例自身已有的内存。如果我们忘记在分配新内存之前释放自身已有的空间，则程序将出现内存泄漏。 判断传入的参数和当前的实例(*this)是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果事先不判断就进行赋值，那么在释放实例自身内存的时候就会导致严重的问题：当*this和传入的参数是同一个实例时，一旦释放了自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。 经典的解法，适用于初级程序员 当我们完整地考虑了上述4个方面之后，可以写出如下的代码： CMyString& CMyString::operator = (const CMyString& str) { if(this == &str) return *this; delete []m_pData; m_pData = nullptr; m_pData = new char[strlen(str.m_pData) + 1]; strcpy(m_pData, str.m_pData); return *this; } 考虑异常安全性的解法，高级程序员必备 在前面的函数中，我们在分配内存之前先用delete释放了实例m_pData的内存。如果此时内存不足导致new char抛出异常，则m_pData将是一个空指针，这样非常容易导致程序崩溃。也就是说，一旦在赋值运算符函数内部抛出一个异常，CMyString的实例不再保持有效的状态，这就违背了异常安全性(Exception Safety)原则。 要想在赋值运算符函数中实现异常安全性，我们有两种方法。一种简单的办法是我们先用new分配新内容，再用delete释放已有的内容。这样只在分配内容成功之后再释放原来的内容，也就是当分配内存失败时我们能确保CMyString的实例不会被修改。我们还有一种更好的办法，即先创建一个临时实例，再交换临时实例和原来的实例。下面是这种思路的参考代码： CMyString& CMyString::operator = (const CMyString& str) { if(this != &str) { CMyString strTemp(str); char*pTemp=strTemp.m_pData; strTemp.m_pData=m_pData; m_pData=pTemp; } return *this; } 在这个函数中，我们先创建一个临时实例strTemp,接着把strTemp.m_pData和实例自身的m_pData进行交换。由于strTemp是一个局部变量，但程序运行到if的外面时也就出了该变量的作用域，就会自动调用strTemp的析构函数，把strTemp.m_pData所指向的内存释放掉。由于strTemp.m_pData指向的内存就是实例之前m_pData的内存，这就相当于自动调用析构函数释放实例的内存。 在新的代码中，我们在CMyString的构造函数里用new分配内存。如果由于内存不足抛出诸如bad alloc等异常，但我们还没有修改原来实例的状态，因此实例的状态还是有效的，这也就保证了异常安全性。 源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/01_AssignmentOperator "},"pages/面试题/实现Singleton模式.html":{"url":"pages/面试题/实现Singleton模式.html","title":"实现Singleton模式","keywords":"","body":"实现Singleton模式 题目：设计一个类，我们只能生成该类的一个实例： 不好的解法一：只适用于单线程环境 由于要求只能生成一个实例，因此我们必须把构造函数设为私有函数以禁止他人创建实例。我们可以定义一个静态的实例，在需要的时候创该实例。下面定义类型Singleton1就是基于这个思路的实现： public sealed class Singleton1 { private Singleton1() { } private static Singleton1 instance = null; public static Singleton1 Instance { get { if (instance == null) instance = new Singleton1(); return instance; } } } 上述代码在Singleton1的静态属性instance中，只有在instance为的时候才创建个实例以避免重复创建。同时我们把构造函数定义为私有函数，这样就能确保只创建一个实例。 不好的解法二：虽然在多线程环境中能工作，但效率不高 解法一中的代码在单线程的时候工作正常，但在多线程的情况下就有问题了。设想如果两个线程同时运行到判断instance是否为null的if语句，并且instance的确没有创建时，那么两个线程都会创建一个实例，此时类型Singleton1就不再满足单例模式的要求了。为了保证在多线程环境下我们还是只能得到类型的一个实例，需要加上一个同步锁。把Singleton1稍作修改得到了如下代码： public sealed class Singleton2 { private Singleton2() { } private static readonly object syncObj = new object(); private static Singleton2 instance = null; public static Singleton2 Instance { get { lock (syncObj) { if (instance == null) instance = new Singleton2(); } return instance; } } } 我们还是假设有两个线程同时想创建一个实例。由于在一个时刻只有一个线程能得到同步锁，当第一个线程加上锁时，第二个线程只能等待。当第一个线程发现实例还没有创建时，它创建出一个实例。接着第一个线程释放同步锁，此时第二个线程可以加上同步锁，并运行接下来的代码。这时候由于实例已经被第一个线程创建出来了，第二个线程就不会重复创建实例了，这样就保证了我们在多线程环境中也只能得到一个实例。 但是类型Singleton2还不是很完美。我们每次通过属性Instance得到Singleton2的实例，都会试图加上一个同步锁，而加锁是一个非常耗时的操作，在没有必要的时候我们应该尽量避免。 可行的解法：加同步锁前后两次判断实例是否已存在 我们只是在实例还没有创建之前需要加锁操作，以保证只有一个线程创建出实例。而当实例已经创建之后，我们已经不需要再执行加锁操作了。于是我们可以把解法二中的代码再做进一步的改进： public sealed class Singleton3 { private Singleton3() { } private static object syncObj = new object(); private static Singleton3 instance = null; public static Singleton3 Instance { get { if (instance == null) { lock (syncObj) { if (instance == null) instance = new Singleton3(); } } return instance; } } } Singleton3中只有当instance为null即没有创建时，需要加锁操作。当instance已经创建出来之后，则无须加锁。因为只在第一次的时候instance为null，因此只在第一次试图创建实例的时候需要加锁。这样Singleton3的时间效率比Singleton2要好很多。 Singleton3用加锁机制来确保在多线程环境下只创建一个实例，并且用两个if判断来提高效率。这样的代码实现起来比较复杂，容易出错，我们还有更加优秀的解法。 强烈推荐的解法一：利用静态构造函数 C#的语法中有一个函数能够确保只调用一次，那就是静态构造函数，我们可以利用C#的这个特性实现单例模式。 public sealed class Singleton4 { private Singleton4() { Console.WriteLine(\"An instance of Singleton4 is created.\"); } public static void Print() { Console.WriteLine(\"Singleton4 Print\"); } private static Singleton4 instance = new Singleton4(); public static Singleton4 Instance { get { return instance; } } } Singleton4的实现代码非常简洁。我们在初始化静态变量instance的时候创建一个实例。由于C#是在调用静态构造函数时初始化静态变量，.NET运行时能够确保只调用一次静态构造函数，这样我们就能够保证只初始化一次instance。 C#中调用静态构造函数的时机不是由程序员掌控的，而是当.NET运行时发现第一次使用一个类型的时候自动调用该类型的静态构造函数。因此在Singleton4中，实例instance并不是在第一次调用属性Singleton4.Instance的时候被创建的，而是在第一次用到Singleton4的时候就会被创建。假设我们在Singleton4中添加一个静态方法，调用该静态函数是不需要创建一个实例的，但如果按照Singleton4的方式实现单例模式，则仍然会过早地创建实 例，从而降低内存的使用效率。 强烈推荐的解法二：实现按需创建实例 最后一个实现Singleton5则很好地解决了Singleton4中的实例创建时机过早的问题。 public sealed class Singleton5 { Singleton5() { Console.WriteLine(\"An instance of Singleton5 is created.\"); } public static void Print() { Console.WriteLine(\"Singleton5 Print\"); } public static Singleton5 Instance { get { return Nested.instance; } } class Nested { static Nested() { } internal static readonly Singleton5 instance = new Singleton5(); } } 在上述Singleton5的代码中，我们在内部定义了一个私有类型Nested。当第一次用到这个嵌套类型的时候，会调用静态构造函数创建Singleton5的实例instance。类型Nested只在属性Singleton5.Instance中被用到，由于其私有属性，他人无法使用Nested类型。因此，当我们第一次试图通过属性Singleton5.Instance得到Singleton5的实例时，会自动调用Nested的静态构造函数创建实例instance。如果我们不调用属性Singleton5.Instance，就不会触发.NET运行时调用Nested，也不会创建实例，这样就真正做到了按需创建。 解法比较 在前面的5种实现单例模式的方法中，第一种方法在多线程环境能正常工作，第二种模式虽然能在多线程环境中正常工作，但时间效率很低，都不是面试官期待的解法。在第三种方法中，我们通过两次判断一次加锁确保在多线程环境中能高效率地工作。第四种方法利用C#的静态构造函数的特性，确保只创建一个实例。第五种方法利用私有嵌套类型的特性，做到只在真正需要的时候才会创建实例，提高空间使用效率。如果在面试中给出第四种或者第五种解法，则毫无疑问会得到面试官的青睐。 源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/02_Singleton "}}