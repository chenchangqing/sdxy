{"pages/游戏UI设计/平面构成的基本形与骨骼.html":{"url":"pages/游戏UI设计/平面构成的基本形与骨骼.html","title":"平面构成的基本形与骨骼","keywords":"","body":"平面构成的基本形与骨骼 组成画面内容的视觉元素个体称为基本形，基本形排列所依照的规则顺序（构图）称为“骨骼”。 1）基本形 当基本形相同时，会产生以下组合关系，其被广泛运用在游戏UI设计中，如图形、图标与花纹设计，如图3-32所示。 分离 接触 重叠 局部透叠 遮挡 残缺 差叠 包容 分离 接触 遮挡 残缺 包容 （2）骨骼 平面构成组成元素的框架叫作“骨骼”，它让一切基本形产生有秩序的编排顺序，或产生感觉上经过刻意编排的顺序，常在游戏UI构图中使用，使画面内容的排列布局清晰。 比如通过骨骼来检查下面这个界面构图中各个区块内容的问题，如图3-33所示。加上骨骼线后，可以看出很多问题，比如骨骼顶部不居中，并且在画面上部整体骨骼框架下显得货币下的构图太空，下面面板中的右边骨骼区域与左边骨骼区域内容高度不同。 我们还可以通过不同类型的骨骼来设计画面。 骨骼分类 按复杂程度分：单一骨骼、复合骨骼。游戏UI设计中大多数都是单一骨骼，偶尔会用到复合骨骼，如图3-34所示。 按功能分 ：有作用性骨骼、无作用性骨骼。 按结构分：有规律性骨骼、半规律性骨骼、非规律性骨骼。 1.有作用性骨骼 骨骼给基本形准确的空间位置，并可影响基本形的形状，基本形都在骨骼内，并可以改变大小、正负、方向、位置、肌理和颜色，骨骼线起划分空间的作用，并分割背景，超出骨骼线的部分可被骨骼线切掉，不可影响其他单位骨骼内的元素。骨骼线与骨骼线内的基本形不一定全部出现，如果不需要可将部分骨骼线与基本形去掉，如图3-35所示。 2无作用性骨格 骨骼不会分割空间，它只给基本形准确的空间位置，基本形安排在骨格的交点上，基本形可以改变大小、正负、方向、肌理和颜色，如图3-36所示。 3.规律性骨格 规律性骨格有精确严谨的骨格线，有规律，基本形按照骨格排列，有强烈的秩序感，主要有重复、渐变、发射和衍变等形式，如图3-37所示。 "},"./":{"url":"./","title":"最近更新","keywords":"","body":"从尾到头打印链表 题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值链表节点定义如下： struct ListNode { int m_nKey; ListNode* m_pNext; }; 看到这道题后，很多人的第一反应是从头到尾输出将会比较简单，于是我们很自然地想到把链表中链接节点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。但该方法会改变原来链表的结构。是否允许在打印链表的时候修改链表的结构？这取决于面试官的要求，因此在面试的时候我们要询问清楚面试官的要求。 面试小提示：在面试中，如果我们打算修改输入的数据，则最好先问面试官是不是允许修改。 通常打印是一个只读操作，我们不希望打印时修改内容。假设面试官也要求这个题目不能改变链表的结构。 接下来我们想到解决这个问题肯定要遍历链表。遍历的顺序是从头到尾，可输出的顺序却是从尾到头。也就是说，第一个遍历到的节点最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的“后进先出”，我们可以用栈实现这种顺序。每经过一个节点的时候，把该节点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出节点的值，此时输出的节点的顺序己经反转过来了。这种思路的实现代码如下： #include \"..\\Utilities\\List.h\" #include void PrintListReversingly_Iteratively(ListNode* pHead) { std::stack nodes; ListNode* pNode = pHead; while(pNode != nullptr) { nodes.push(pNode); pNode = pNode->m_pNext; } while(!nodes.empty()) { pNode = nodes.top(); printf(\"%d\\t\", pNode->m_nValue); nodes.pop(); } } 既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构，于是很自然地又想到了用递归来实现。要实现反过来输出链表，我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。 基于这样的思路，不难写出如下代码： void PrintListReversingly_Recursively(ListNode* pHead) { if(pHead != nullptr) { if (pHead->m_pNext != nullptr) { PrintListReversingly_Recursively(pHead->m_pNext); } printf(\"%d\\t\", pHead->m_nValue); } } 上面的基于递归的代码看起来很简洁，但有一个问题：当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一些。更多关于循环和递归的讨论，详见本书的2.4.1节。 剑指 Offer P58，本题完整的源代码：https://github.com/zhedahht/CodingInterviewChinese2/tree/master/06_PrintListInReversedOrder 备案号： -->沪ICP备2022002183号-1 "}}