{"pages/jsp/principles.html":{"url":"pages/jsp/principles.html","title":"JSP原理","keywords":"","body":"JSP原理 23.12.16 1:16更新 我的第一个JSP程序 1）在WEB-INF目录之外创建一个index.jsp文件，然后这个文件没有任何内容。2）在上面的项目部署之后，启动服务器，打开浏览器访问以下路径 ，展示空白页面。 http://localhost:8080/jsp/index.jsp 3）实际上访问index.jsp，底层执行的是index_jsp.class这个java程序。4）这个index.jsp会被tomcat翻译生成index_jsp.java文件，然后tomcat服务器又会将index_jsp.java编译生成index_jsp.class文件。 控制台找到： CATALINA_BASE: C:\\Users\\Administrator\\AppData\\Local\\JetBrains\\IntelliJIdea2021.3\\tomcat\\xxx index_jsp.java路径： CATALINA_BASE\\work/Catalina\\localhost\\jsp\\org\\apache\\jsp\\index_jsp.java 5）访问index.jsp，实际上执行的是index_jsp.class中的方法。 JSP实际是一个Servlet 1）index.jsp访问的时候，会自动翻译生成index_jsp.java，会自动翻译生成index_jsp.class，那么index_jsp这就是一个类。2）index_jsp类继承HttpJspBase，而HttpJspBase类继承的是HttpServlet。所以index_jsp类就是一个Servlet类。3）jsp的生命周期和Servlet的生命周期完全相同。完全就是一个东西，没有任何区别。4）jsp和servlet一样，都是单例的。（假单例） JSP文件第一次访问的时候是比较慢的，为什么？ 1）要把jsp文件翻译生成java文件。2）java源文件要编译生成class字节码文件。3）然后通过class去创建servlet对象。4）然后调用servlet对象的init方法。5）最后调用servlet对象的service方法。 第二次就比较快了，为什么？因为第二次直接调用单例servlet对象的esrvice方法即可。 JSP是什么？ 1）JSP是java程序。（JSP本质还是一个Servlet）2）JSP是：JavaServer Pages的缩写。（基于java语言实现的服务器的页面）3）Servlet是JavaEE的13个子规范之一，那么JSP也是13个子规范之一。4）JSP是一套规范。所有的web容器/web服务器都是遵循这套规范的，都是按照这套规范进行的“翻译”。5）每一个web容器/web服务器都会内置一个JSP翻译引擎。 翻译JSP 在JSP文件中直接编写文件，都会自动被翻译到哪里？ 1）翻译到servlet类的service方法的out.writer(\"翻译到这里\")，直接翻译到双引号里，被java程序当做普通字符串打印输出到浏览器。2）在JSP中编写的HTML CSS JS代码，这些代码对于JSP来说只是一个普通的字符串。但是JSP把这个普通的字符串一旦输出到浏览器，浏览器就会对HTML CSS JS进行解释执行，展示页面效果。 中文乱码 通过page指令来设置响应的内容类型，在内容类型的最后面添加：charset=UTF-8。 表示响应的内容类型是text/html，采用字符集UTF-8。 1）在这个符号当中编写的被视为java程序，被翻译到Servlet类的service方法内部。 注意：在这个符号里面写java代码的时候，要时时刻刻地记住你正在“方法提”当中写代码，方法体中可以写什么，不可以写什么。 2）在service方法当中编写的代码是有顺序的，方法体当中的代码要遵循自上而下的顺序依次逐行执行。3）service方法当中不能写静态代码块，不能写方法，不能定义成员变量。4）在同一个JSP当中这个符号可以出现多个。 在这个符号中编写的java程序自动翻译到service方法之外。 这个语法很少用，因为在service方法外面写静态变量和实例变量，都会存在线程安全问题，JSP就是servlet，servlet是单例的，多线程并发的环境下，这个静态变量和实例变量一旦有修改操作，必然会存在线程安全问题。 JSP的专业注释，不会被翻译到java源代码当中。 这种注释属于HTML的注视，仍然会被翻译到java源代码当中。 JSP的输出语句 注意：以上代码中的out是JSP的九大内置对象之一。可以直接拿来用。当然，必须只能在service方法内部使用。 如果向浏览器傻姑娘输出的内容中没有“java代码”，例如输出的字符串是一个固定的字符串，可以直接在jsp中编写，不需要写到这里。 在等号后面编写要输出的内容，翻译成以下java代码，翻译到service方法当中了。 out.print(); 当输出的内容中含有java的变量，输出的内容是一个动态的内容，不是一个死的字符串。如果输出是一个固定的字符串，直接在JSP文件中编写科技。 JSP指令 指导JSP的翻译引擎如何工作。 include：包含，在JSP中完成静态包含。 taglib：引入标签库，例如：JSTL标签。 page：可以指定contetType等 语法： page指令 ：true表示启用JSP的内置对象session，false，反之不启用session。 ：contentType属性用来设置响应的内容类型。 ：设置字符集编码。 和 功能一样。 ：导入包。 ：当java程序出现错误后，会跳转到error.jsp页面。 注意：当配置了errorPage时，需要在errorPage输出错误堆栈信息，要不然程序员无法获取错误信息日志。 ：表示启用JSP九大内置对象之一：exception，默认是false。配置错误error.jsp页面： error 网络繁忙，稍后再试！！！ JSP的九大内置对象 pageContext：页面作用域。 request：请求作用域。 session：会话作用域。 application：应用作用域。 pageContext 以上四个作用域都用：setAttribute getAttribute removeAttribute class中的方法。 以上作用域的使用原则：尽可能使用小的域。 exception：打印异常堆栈信息。 config：获取web.xml的配置信息。 page：其实就是this，当前的servlet对象。 out：负责输出。 response：负责响应。 视频 start:https://www.bilibili.com/video/BV1Z3411C7NZ?p=36 end:https://www.bilibili.com/video/BV1Z3411C7NZ?p=37 end:https://www.bilibili.com/video/BV1Z3411C7NZ?p=50 "},"pages/jsp/servletjsp.html":{"url":"pages/jsp/servletjsp.html","title":"Servlet+JSP项目改造","keywords":"","body":"Servlet+JSP项目改造 使用Servlet处理业务，收集数据，使用JSP展示数据。 修改html为jsp 修改html为jsp，然后在jsp文件头步添加page指令（指定contentType防止中文乱码，将所有JSP直接拷贝至web目录下。 使用替换超链接的根路径。 修改Servlet 1）将数据集合list存储到request域当中。2）转发forward到jsp。 修改JSP 1）从request域取出List集合。2）遍历List集合，取出每个对象，动态生成tr。 如果只用JSP这一个技术，能不能开发web应用？ 当然可以使用JSP来完成所有的功能，因为JSP就是Servlet，在JSP的里面写的代码就是在service方法当中的，所以在当中完全可以编写JDBC代码，连接数据库，查询数据，也可以在这个方法当中编写业务逻辑代码，处理业务，都是可以的，所以使用单独的JSP开发web应用完全没问题。 虽然JSP一个技术就可以完成web应用，但是不建议，还是建议采用servlet+jsp的方式进行开发。这样都能将各自的优点发挥出来，JSP就是做数据展示，Servlet就是做数据的收集。 JSP中编写的java代码越少越好，一定要职责分明。 JSP文件的扩展名必须是xxx.jsp吗？ jsp文件的扩展名是可以配置的，不是固定的，在CATALINA_HOME/conf/web.xml可以配置jsp文件的扩展名： jsp *.jsp *.jspx xxx.jsp文件对于tomcat来说，只是一个普通的文本文件，web容器会将xxx.jsp文件最终生成java程序，最终调用的是java对象相关的方法，真正执行的时候，和 jsp文件就没有关系了。 包名bean是什么意思？ 1）javabean：java的logo是一杯冒着热气的咖啡，javabean被翻译为咖啡豆。2）java是一杯咖啡，咖啡又是由一粒一粒的咖啡研磨而成。3）整个java程序中有很多bean的存在，由很多bean组成。 4）javabean其实就是java中的实体类，负责数据的封装。5）由于javabean符合javabean规范，具有更强的通用性。 什么是javabean？ 1）有无参数构造方法2）属性私有化3）对外提供公开的set和get方法4）实现java.io.Serializable接口5）重写toString6）重写hashCode+equals "},"pages/jsp/session.html":{"url":"pages/jsp/session.html","title":"Session","keywords":"","body":"Session 什么是会话？ 用户打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做：一次会话。会话在服务器端也有一个对应的java对象，这个java对象叫做session。 什么是一次请求：用户在浏览器上点击了一下，然后在页面停下来，可以粗略认为是一次请求。请求对应的服务器的java对象是request。 一次会话当中包含多次请求。 在java的servlet规范当中，session对象类名：HttpSession(jarkata.servlet.http.HttpSession)。 session机制属于B/S结构的一部分。如果使用php语言开发WEB项目，同样也是有session这种机制的。session机制实际上是一种规范。然后不同的语言对这种会话机制都有实现。 Session的作用 保存会话状态：用户登录成功了，这是一种刚登陆成功的状态，你怎么把登录成功的状态一只保存起来？使用session对象可以保留会话状态。 为什么需要session对象来保存会话状态呢？ 因为HTTP协议是一种无状态协议。只要B和S断开了，那么关闭浏览器这个动作，服务器知道吗？不知道，服务器不知道浏览器关闭的。 什么是无状态：请求的时候，B和S是连接的，但是请求结束之后，连接就断了。为什么要这么做？HTTP协议为什么要设计成这样？因为这样的无状态协议，可以降低服务器的压力，请求的瞬间是连接的，请求结束后，连接断开，这样服务器压力小。 为什么不使用request对象保存会话状态？ 同问：为什么不是用ServletContext对象保存会话状态？ request是一次请求一个对象。 ServletContext对象是服务器启动的时候创建，服务器关闭的时候销毁，这个ServletContext对象只有一个。 ServletContext对象的域太大。 request请求域（HttpServletRequest)、session会话域（HttpSession）、application域（ServletContext) request小于session小于application。 思考一下 HttpSession session = request.getSession()； 这行代码很神奇：张三访问的时候获取的session对象就是张三的；李四访问的时候获取的session对象就是李四的。 session的实现原理 JSESSIONID=xxxx 这个是一Cookie的形式保存在浏览器的内存中的。浏览器只要关闭，这个cookie就没有了。 session列表是一个Map，map的key是sessionid，map的value是session对象。 用户第一次请求，服务器生成session对象，同时生成ID，将ID发送给浏览器。 用户第二次请求，自动将浏览器内存中的ID发送给服务器，服务器根据ID查找session对象。 关闭浏览器，内存消失，cookie消失，sessionid消失，会话等同于结束。 Cookie禁用了，session还能找到吗？ cookie禁用是什么意思？服务器正常发送cookie给浏览器，但是浏览器不要了，拒收了，并不是服务器不发了。 找不到了，每次请求都会获取到新的session对象。 cookie禁用了，session机制还能实现吗？可以，需要使用URL重写机制。 http://xxxx;jsessionid=DD5EC49931F2AC378DC68548C9E5?v=f050045a0c URL重写机制会提高开发者的成本，开发人员在编写任何请求路径的时候，后面都要添加一个sessionid，给开发带来了很大的难度，很大的成本，所以大部分的网站都是这样设计：你要是禁用cookie，你就别用了。 销毁session对象 session.invalidate(); JSP禁用session 视频 start:https://www.bilibili.com/video/BV1Z3411C7NZ?p=44 end:https://www.bilibili.com/video/BV1Z3411C7NZ?p=45 "},"pages/jsp/cookie.html":{"url":"pages/jsp/cookie.html","title":"Cookie","keywords":"","body":"Cookie 23.12.15 2:20 更新 什么是cookie？ 在session实现原理中，jsessionid=DD5EC49931F2AC378DC68548C9E5?v=f050045a0c，这个键值对数据就是cookie对象，是一串字符串。 cookie机制和sesion机制其实都不属于java中的机制，实际上cookie机制和session机制都是HTTP协议的一部分。php开发中也有cookie和session机制，只要做web开发，不管是什么编程语言，cookie和session机制都是需要的。 HTTP协议中规定：任何一个cookie都是name和value组成的，name和value都是字符串类型的。 cookie保存在哪里？ 可以保存在浏览器的运行内存中，浏览器只要关闭，cookie就消失了。 也可以保存在硬盘文件中，永久保存。 cookie有啥用？ cookie和session机制其实都是为了保存会话的状态。 cookie是将会话的状态保存在浏览器客户端上。 session是将会话的状态保存在服务器上。 为什么要有cookie和session机制呢？因为HTTP协议是无状态无连接协议。 十天免登录 在126邮箱中有一个功能：十天免登录。怎么实现的？ 用户输入正确的用户名和密码，并且同时选择十天内免登录。登录成功后，浏览器客户端会保存一个cookie，这个cookie中保存了用户名和密码等信息，这个cookie是保存在硬盘文件当中，十天有效，在十天内用户再次访问126的时候，浏览器自动提交126关联的cookie给服务器，服务器收到cookie之后，获取用户名和密码，验证，通过之后，自动登录成功。 怎么让cookie失效？ cookie过期 修改密码 在浏览器上清除cookie Cookie类 在java的servlet中，对cookie提供了哪些支持呢？ java提供了一个Cookie类类专门表示cookie数据，jakarta.servlet.http.Cookie java程序怎么把cookie数据发送给浏览器呢？response.addCookie(cookie) 在HTTP协议中是这样规定的：当浏览器发送请求的时候，会自动携带该path下的cookie数据给服务器。（URL） API：https://tomcat.apache.org/tomcat-7.0-doc/servletapi/index.html cookie的有效时间 // 设置cookie在一小时后失效，保存在硬盘中 cookie.setMaxAge(60*60); // 设置cookie的有效期为0，表示删除cookie，主要应用在：使用这种方式删除浏览器上的同名cookie cookie.setMaxAge(0); // 设置cookie的有效期 cookie的path 假设现在发送的请求路径是http://localhost:8080/servlet13/cookie/generate生成cookie，如果cookie没有设置path，默认的path是什么？ 默认的path是：http://localhost:8080/servlet13/cookie及它的子路径。 也就是说，以后只要浏览器请求的路径是http://localhost:8080/servlet13/cookie及它的子路径，cookie都会被发送到服务器。 手动设置cookie的path：cookie.setPath(\"servlet13\");表示只要是这个servlet13项目的请求路径，都会提交这个cookie给服务器。 服务器获取cookie Cookie[] cookies = request.getCookies(); // 如果不是null，表示一定有cookie if (cookies != null) { // 遍历数组 for (Cookie cookie: cookies) { // 获取cookie的name和value String name = cookie.getName(); String value = cookie.getValue(); System.out.println(name + \"=\" + value); } } 视频 start:https://www.bilibili.com/video/BV1Z3411C7NZ?p=47 "},"pages/jsp/el.html":{"url":"pages/jsp/el.html","title":"EL表达式","keywords":"","body":"EL表达式 23.12.16 15:8开始 23.12.16 22:39更新 EL表达式是什么？ Expression Language（表达式语言） EL表达式可以代替JSP中的java代码，让JSP文件中的程序看起来更加整洁，美观。 JSP中夹杂着各种java代码，例如：、等，导致JSP文件很混乱，不好看，不好维护，所以才有了后期的EL表达式。 EL表达式可以算是JSP语法的一部分，EL表达式归属于JSP。 EL表达式作用 从某个域中取数据。 将取出的数据转成字符串。 将字符串输出到浏览器。 EL表达式使用 语法：${表达式} ${userObj} ${这里位置写什么？这里写的一定是存储到域对象当中时的name} ${userObj} 等同于代码 不要这样写：${\"userObj\"} ${userObj}底层怎么做的？ 从域中取数据，取出user对象，然后调用user对象的toString方法，转成字符串，输出到浏览器。 怎么输出对象的属性值？ ${userObj.username}：使用这个语法的前提是：User对象有getUsername()方法。 ${userObj.password} ${userObj.age} ${userObj.email} ${userObj.address.street}：支持.语法 EL表达式对null进行了处理，如果是null，则在浏览器上显示空白。 EL表达式中这个语法，实际上调用了底层的getXXX()方法，getXXX方法的名称不使用驼峰命名也是可以的，但是不推荐。 EL表达式取数据优先级 在没有指定域范围的前提下，EL表达式优先从小范围中取数据. 域范围大小：pageContext EL表达式中有四个隐式的范围，可以指定域范围来读取数据： ${pageScope.data}：pageContext域 ${requestScope.data}：request域 ${sessionScope.data}：session域 ${applicationScope.data}：application域 在实际开发中，因为向某个域中存储数据的时候，name都是不同的，所以，xxxScope都是可以省略的。 EL表达式取数据的方式 ${user.username}：一般使用这种就够用了。 ${user[\"username\"]}：如果存储到域的时候，这个name中含有特殊字符，可以使用[]方式，例如：name=\"xxx.xxx\"。 怎么从Map取数据？${map.key} 怎么从Array取数据？${array[0]}：取出数组中第一个元素输出 取不出数据，在浏览器显示空白，不会出现下标越界问题。 忽略EL表达式 page指令当中，有一个属性，可以忽略EL表达式： isELIgnored=\"true\"：表示忽略EL表达式 isELIgnored=\"false\"：表示不忽略EL表达式，默认false。 isELIgnored=\"true\"表示忽略JSP中整个页面的EL表达式，如果想忽略其中某个，可以使用反斜杠：${username}。 使用EL表达式获取应用的根 ${pageContext.request.contextPath} 获取请求参数、应用域配置参数 ${param.aihao}：获取request中参数为aihao的值。相当于以下代码： ${paramValues.aihao[0]}：当aihao对应多个值的时候使用。相当于以下代码： ${initParam.pageNum}：获取web.xml中context初始化参数。相当于以下代码： application.getInitParameter(\"pageNum\")； 算术运算符：+ - * / % ${10+20}：显示30。 ${10+\"20\"}：“20”会自动转成数字，再相加，显示30。 ${10+\"abc\"}：报数字格式化错误，NumberFormatException。 +号在EL表达式中，只会做求和，不会做字符串拼接。 关系运算符：== != > >= ${\"abc\"==\"abc\"}：显示true。 ${k1 == k2}：显示true。 ${s1 == s2}：显示true，因为String重写了equals方法。 ${obj1 == obj2}：显示false。 ==调用了equals方法。 == 和 eq效果一致。 ${!stu1 eq stu2}：错误的写法。 ${!(stu1 eq stu2)}：正确的写法。 ${not(stu1 eq stu2)}：正确的写法。 空运算符：empty ${empty param.username}：判空 ${!empty param.username}：判非空 ${not empty param.username}：判非空 ${empty param.password == null}：前半部分是boolean， false == null，显示false。 其他运算符 逻辑运算符：! && || not and or 条件运算符：? : ${empty param.username ? \"对不起，用户名不能为空\" : \"欢迎访问\"} 取值运算符：[] . 视频 start：https://www.bilibili.com/video/BV1Z3411C7NZ?p=51 end：https://www.bilibili.com/video/BV1Z3411C7NZ?p=53 "},"pages/jsp/jstl.html":{"url":"pages/jsp/jstl.html","title":"JSTL标签库","keywords":"","body":"JSTL标签库 23.12.16 22:45开始 23.12.17 21:39更新 什么是JSTL标签库？ Java Standard Tag Lib（Java标准的标签库） JSTL标签库通过结合EL表达式一起使用，目的是让JSP的java代码消失。 标签是写在JSP当中的，但是实际上最终还是要执行对应的java程序。 引入JSTL标签库对应的jar包 在tomcat10及之后引入的jar： jakarta.servlet.jsp.jstl-2.0.0.jar jakarta.servlet.jsp.jstl-api-2.0.0.jar tomcat10之前使用： javax.servlet.jsp.jstl-2.0.0.jar taglibs-standard-impl-1.2.5.jar taglibs-standard-spec-1.2.5.jar 在IDEA当中怎么引入？ 在WEB-INF下新建lib目录，然后将jar包拷贝到lib当中，然后将其“Add Lib...”。 一定是要和mysql的数据库驱动一样，都是放在WEB-INF/lib目录下的。 什么时候需要将jar包放到WEB-INF/lib目录下？如果这个jar是tomcat服务器没有的。 在JSP中引入要使用的标签库 使用taglib指令引入标签库： 这个是核心标签库。 以上uri后面的路径实际上指向了一个c.tld文件。 c.tld路径：在jakarta.servlet.jsp.jstl-2.0.0.jar里面META-INF目录下。 c.tld文件实际是一个xml配置文件。 配置文件tld解析 对该标签的描述 catch标签的名字 org。apache.taglibs.standard.tag.common.core.CatchTag标签对应的java类 JSP标签体当中可以出现的内容，如果是JSP，就表示标签体中可以出现符合JSP所有语法的代码，例如EL表达式。 对这个属性的描述 var属性名 falsefalse表示该属性不是必须的，true则反之。 false这个描述说明了该属性是否支持EL表达式，false表示不支持，true表示支持EL表达式。 catch JSP... forEach id:¥{varStatus.count},${s.id},name:${s.name} ${i} if 没有else标签，可以使用两个if。 if标签还有var属性，不是必须的。 if标签还有scope属性，用来指定var的存储域，也不是必须的 scope有四个值可以选：page、request、session、application 将var中的v存储到request域。 欢迎你${param.username}。 choose 青少年 青年 中年 老年 HTML中的base xxx 注意：html的base标签可能对JS代码不起作用，所以JS代码最好前面写项目根路径： document.location.href = \"${pageContext.request.contextPath}/dept/delete?deptno=\" + dno; 动态获取base： 视频 start://www.bilibili.com/video/BV1Z3411C7NZ?p=54 end://www.bilibili.com/video/BV1Z3411C7NZ?p=55 "},"pages/jsp/filter.html":{"url":"pages/jsp/filter.html","title":"过滤器","keywords":"","body":"过滤器 23.12.17 21:59开始 过滤器实现原理图 "},"./":{"url":"./","title":"最近更新","keywords":"","body":"EL表达式 23.12.16 15:8开始 23.12.16 22:39更新 EL表达式是什么？ Expression Language（表达式语言） EL表达式可以代替JSP中的java代码，让JSP文件中的程序看起来更加整洁，美观。 JSP中夹杂着各种java代码，例如：、等，导致JSP文件很混乱，不好看，不好维护，所以才有了后期的EL表达式。 EL表达式可以算是JSP语法的一部分，EL表达式归属于JSP。 EL表达式作用 从某个域中取数据。 将取出的数据转成字符串。 将字符串输出到浏览器。 EL表达式使用 语法：${表达式} ${userObj} ${这里位置写什么？这里写的一定是存储到域对象当中时的name} ${userObj} 等同于代码 不要这样写：${\"userObj\"} ${userObj}底层怎么做的？ 从域中取数据，取出user对象，然后调用user对象的toString方法，转成字符串，输出到浏览器。 怎么输出对象的属性值？ ${userObj.username}：使用这个语法的前提是：User对象有getUsername()方法。 ${userObj.password} ${userObj.age} ${userObj.email} ${userObj.address.street}：支持.语法 EL表达式对null进行了处理，如果是null，则在浏览器上显示空白。 EL表达式中这个语法，实际上调用了底层的getXXX()方法，getXXX方法的名称不使用驼峰命名也是可以的，但是不推荐。 EL表达式取数据优先级 在没有指定域范围的前提下，EL表达式优先从小范围中取数据. 域范围大小：pageContext EL表达式中有四个隐式的范围，可以指定域范围来读取数据： ${pageScope.data}：pageContext域 ${requestScope.data}：request域 ${sessionScope.data}：session域 ${applicationScope.data}：application域 在实际开发中，因为向某个域中存储数据的时候，name都是不同的，所以，xxxScope都是可以省略的。 EL表达式取数据的方式 ${user.username}：一般使用这种就够用了。 ${user[\"username\"]}：如果存储到域的时候，这个name中含有特殊字符，可以使用[]方式，例如：name=\"xxx.xxx\"。 怎么从Map取数据？${map.key} 怎么从Array取数据？${array[0]}：取出数组中第一个元素输出 取不出数据，在浏览器显示空白，不会出现下标越界问题。 忽略EL表达式 page指令当中，有一个属性，可以忽略EL表达式： isELIgnored=\"true\"：表示忽略EL表达式 isELIgnored=\"false\"：表示不忽略EL表达式，默认false。 isELIgnored=\"true\"表示忽略JSP中整个页面的EL表达式，如果想忽略其中某个，可以使用反斜杠：${username}。 使用EL表达式获取应用的根 ${pageContext.request.contextPath} 获取请求参数、应用域配置参数 ${param.aihao}：获取request中参数为aihao的值。相当于以下代码： ${paramValues.aihao[0]}：当aihao对应多个值的时候使用。相当于以下代码： ${initParam.pageNum}：获取web.xml中context初始化参数。相当于以下代码： application.getInitParameter(\"pageNum\")； 算术运算符：+ - * / % ${10+20}：显示30。 ${10+\"20\"}：“20”会自动转成数字，再相加，显示30。 ${10+\"abc\"}：报数字格式化错误，NumberFormatException。 +号在EL表达式中，只会做求和，不会做字符串拼接。 关系运算符：== != > >= ${\"abc\"==\"abc\"}：显示true。 ${k1 == k2}：显示true。 ${s1 == s2}：显示true，因为String重写了equals方法。 ${obj1 == obj2}：显示false。 ==调用了equals方法。 == 和 eq效果一致。 ${!stu1 eq stu2}：错误的写法。 ${!(stu1 eq stu2)}：正确的写法。 ${not(stu1 eq stu2)}：正确的写法。 空运算符：empty ${empty param.username}：判空 ${!empty param.username}：判非空 ${not empty param.username}：判非空 ${empty param.password == null}：前半部分是boolean， false == null，显示false。 其他运算符 逻辑运算符：! && || not and or 条件运算符：? : ${empty param.username ? \"对不起，用户名不能为空\" : \"欢迎访问\"} 取值运算符：[] . 视频 start：https://www.bilibili.com/video/BV1Z3411C7NZ?p=51 end://www.bilibili.com/video/BV1Z3411C7NZ?p=53 备案号： -->沪ICP备2022002183号-1 "}}